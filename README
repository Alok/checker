-*- coding: utf-8; fill-column: 87; mode: text; mode: auto-fill -*-

An attempt at making a toy proof checker for experimental purposes

This program encodes the type system TS developed in the paper "A universe
polymorphic type system", by Vladimir Voevodsky, the version dated October,
2012, and attempts to make a toy prototype proof assistant based on it.

Thanks to:

    Vladimir Voevodsky                  for TS and Univalence

    Andrej Bauer                        for advice about coding and
				        suggesting Logical Frameworks (LF) as the
				        way to go

    Bob Harper and Dan Licata           for explaining LF in an intuitive way

    Bob Harper and Christopher Stone    for the type checking algorithms used here

-----------------------------------------------------------------------------

Syntax, existing and proposed:

New syntactic class:

      TS "judgment" expressions that represent LF types

      		[ T type ]
		[ o : T ]
		[ T = U ]
		[ o = o' : T ]

     introduced by the Rule or Axiom command with :: (instead of : ).

New operators for TS format:

    /		left associative		TS form for TS substitution, translated
    					    	to LF application. 

    |->		right associative		TS arrow form for TS lambda and LF form
                       				for LF lambda.  Unicode: ↦ or ⟼

    =>		right associative		TS arrow form for LF Pi types.
    						Translated to LF -> .  Unicode: ⇒

    |=>		right associative		TS arrow form for LF lambda.
    						Translated to LF |-> .  Unicode: ⟾

    :		non-associative			TS and LF form for something having a
    						type.  But types in TS are objects in
    						LF, whereas judgments of TS are types in LF.

    ::		non-associative			TS format for expressing a derivation
						of a judgment. Translated to LF colon

    |-		non-associative			TS format for introducing the local
    						context for a judgment.  Unicode: ⊢

    { ... |- ... } =>				TS form corresponding to two parameters
    						in an LF Pi type.

Examples:

    f t                     LF evaluation in LF form

    f[t/x]                  LF evaluation in traditional form, not a good notation,
    			    because x should be considered bound in f 

    f/t                     LF evaluation in TS form



    lambda x, b             the LF lambda in LF form

    x |-> b                 the LF lambda in LF form

    x |=> b                 the LF lambda in TS form



    [lambda;x](f,o,U)       the TS lambda, in full TS form

    [lambda](f,o,x|=>U)     the TS lambda, in full TS form, an alternative

    lambda x:T, o           the TS lambda, in abbreviated TS form

    (x:T) |-> o             the TS lambda, in abbreviated TS form, proposed as an
    			    alternative 

    ([lambda] f o (x|->U))  the TS lambda, in full LF form



    [ev;x](f, t, U)         TS evaluation in full TS form

    [ev](f, t, x |=> U)     TS evaluation in full TS form

    f t                     TS evaluation in abbreviated TS form

    ([ev] f t (x |-> U))    TS evaluation in LF form



    T -> U                  the TS function type in TS form

    Pi x:T, U               the TS Pi in TS form, abbreviated

    [Pi;x](T,U)             the TS Pi in TS full form, to be revised

    [Pi](T,x |=> U)         the TS Pi in TS full form, proposed

    ([Pi] T (x |-> U)       the TS Pi in LF form



    A -> B                  LF function type in LF form

    A => B                  LF function type in TS form

    (x:T) -> U              the LF Pi in LF form

    Pi x:T, U               the LF Pi in LF form



    { |- T Type } ...       TS form for the LF type (T:(T1:texp) × istype T1) ⟶  ...

    { |-  b:U } ...         TS form for the LF type

    				(b : ((b:oexp) × hastype b T₁) ⟶ ...

    { x:T |- U Type } ...   TS form notation for LF

    				(U : (U:oexp ⟶ texp) × 
				     ((x:oexp) ⟶ hastype x T₁ ⟶ istype (U x))) 
				 -> ... 
				 
				    and in ... U gets replaced by U₁

    { x:T |- b:U } ...      TS form notation for LF type

				( b : (b':oexp ⟶ oexp) × 
					((x:oexp) ⟶ hastype x T ⟶ hastype (b' x) U₁))
				-> ...

				and in ... b gets replaced by b₁

-----------------------------------------------------------------------------

There's a problem on my screen with the width of the subscripted numerals.
They're 20% too wide:

    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
    MM₁₁₁₁MMMMMMMMMMMMMMMMM₁₁₁₁MMMMMMMM
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

C-H C-P gives this advice about that:

    *** Some of the fonts called for in your fontset may not exist on your
    X server.

    Each X11 font covers just a fraction of the characters that Emacs
    supports.  To display the whole range of Emacs characters requires
    many different fonts, collected into a fontset.  You can remedy the
    problem by installing additional fonts.

    The intlfonts distribution includes a full spectrum of fonts that can
    display all the characters Emacs supports.  The etl-unicode collection
    of fonts (available from <URL:ftp://ftp.x.org/contrib/fonts/> and
    <URL:ftp://ftp.xfree86.org/pub/mirror/X.Org/contrib/fonts/>) includes
    fonts that can display many Unicode characters; they can also be used
    by ps-print and ps-mule to print Unicode characters.

    ** Under X11, some characters appear improperly aligned in their lines.

    You may have bad X11 fonts; try installing the intlfonts distribution
    or the etl-unicode collection (see above).

-----------------------------------------------------------------------------

See

	ProofGeneral/lib/unicode-tokens.el

for an alternative to putting unicode into files.

-----------------------------------------------------------------------------

Definition parameters:


coq format		LF translation

T : Type		((T:texp) * (istype T))

t : T			((t:oexp) * (hastype t T))

X : T -> Type		((X:oexp->texp) * ((t : ((t:oexp) * (hastype t T))) -> (istype (X t)))

X : Type -> Type	((X:texp->texp) * ((T : ((T:texp) * (istype T))) -> (istype (X T))

-----------------------------------------------------------------------------

references:

Binary bidirectional algorithm for LF:
http://www.cs.cmu.edu/~rwh/papers/lf-theory/lf-theory.pdf

Simplest unifiication for first-order terms:
http://www.cs.cmu.edu/~fp/courses/lp/lectures/06-unif.pdf

Higher-order pattern unification
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.190.4789

-----------------------------------------------------------------------------

We need a pretty printer that can make something like this:

compose0'' = u ⟼ T ⟼ U ⟼ V ⟼ g ⟼ f ⟼ t ⟼ 
	     (pair 
	     	([ev] g₁ ([ev] f₁ t₁ (_ ⟼ ([El] U₁))) (_ ⟼ ([El] V₁))) 
		(ev_hastype 
		  (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
		  (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)) 
		  (pair g₁ (cast
		  	     (pair 
		  		([El] ([∀] u u U₁ (_ ⟼ V₁)) 
				(El_istype 
					u 
					(pair ([∀] u u U₁ (_ ⟼ V₁)) 
					      (forall u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂)))₂))₂) 
		   	     (pair ([∏] ([El] U₁) (_ ⟼ ([El] V₁))) 
			           (∏_istype (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
				   	     (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)))₂) 
			     (pair g₁ g₂) 
			     (El_forall_reduction u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂))))₂) 
		  (pair ([ev] f₁ t₁ (_ ⟼ ([El] U₁)))
		        (ev_hastype 
			    (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂)
			    (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)) 
			    (pair f₁ 
			          (cast (pair ([El] ([∀] u u T₁ (_ ⟼ U₁))) 
				  	      (El_istype 
					      	u 
					      	(pair 
						  ([∀] u u T₁ (_ ⟼ U₁)) 
						  (forall u u (pair T₁ T₂)
						  	      (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂)))₂))₂) 
				        (pair ([∏] ([El] T₁) (_ ⟼ ([El] U₁)))
					      (∏_istype (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂) 
					      	        (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)))₂) 
					(pair f₁ f₂) 
					(El_forall_reduction u u (pair T₁ T₂) (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂))))₂) 
			    (pair t₁ t₂))₂))₂)
-----------------------------------------------------------------------------

Problem 1:

	If the premise is { |- U Type } then that means

	U : (U:texp) × istype U)

	If the premise is { x:T |- U Type } then that means

	U : (U:oexp ⟶ texp) × ((x:oexp) ⟶ hastype x T₁ ⟶ istype (U x))

	We need a way to convert one like the first one to one like the second one.

	It's (pair (_ |-> U_1) (_ |-> _ |-> U_2)).  One way to do that is with
	auto-introduction.

Problem 2:

	If we have two premises { t:T |- u:U } { u:U |- V Type }, then we
	ought to be able to compose U with V to satisfy another premise of the
	form { x:T |- V Type }.  This means we have

	u : (u':oexp ⟶ oexp) × ((t:oexp) ⟶ hastype t T ⟶ hastype (u' t) U₁)

	V : (V:oexp ⟶ texp) × ((u:oexp) ⟶ hastype u U₁ ⟶ istype (V u))

	and we want

	VU : (VU:oexp ⟶ texp) × ((t:oexp) ⟶ hastype t T₁ ⟶ istype (VU t))

	There's a formula for that.

Solution: The judgment generated by our Theorem/Axiom syntax is wrong.  Hypotheses and
conclusions are sigma types, but the type represented by a theorem should not be
a function type between sigma types.  Instead, it should be a "compatible map"
between sigma types.

For example, instead of a function type

    	(T:texp) × istype T ⟶ (t:texp) × istype t

we want maps on pairs that are compatible with a map on first factors:

    	texp ⟶ texp

And there might be dependencies.

In general, we have a dependent product type

   	p' : (a : (a':A) × B) ⟶ ((c:C) × D)

that we want to be compatible with a dependent product type

   	p1 : (a:A) ⟶ C

So what we really want is a pair

   	p1 : (a:A) ⟶ C

	p2 : (a:A) ⟶ B ⟶ D

Typically 'a' is an expression, C is a judgment about it, 'p2 a' is the expression
provided by the proof of the theorem, and D is the judgment about it.

It would be nice for the judgment D to refer to c rather than to 'p1 a', since it's
about c, and we can save space by not substituting c in.

Wait, that's why we used singleton types, to provide the projection onto the first
component.  Can we use singleton types to get the compatibility?  As here:

   	p' : (a : (a':A) × B) ⟶ (c:Singleton(cc:C) × D)

Here cc is 'p1 a'.

an attempt at making a toy proof checker for experimental purposes

Inline long-form notation for definitions, proofs, and derivations, relative to the context
in effect in the term:

   Provisional: definitions involve lazy substitution from one context into another.
   		(we might also want lazy substitution within the same context)
       [udef;name](u1,...; u,...; eqn1,...;R)		here u is a universe level and we add [ name :: |- u : Univ ] to the context and return R
       [tdef;name](u1,...;T1,...;o1,...; T,R)		here T is a type and we add [ name :: |- T : Type ] to context and return R
       [odef;name](u1,...;T1,...; o,T,R)		here o is an object of type T and we add [ name :: |- o : T ] to the context

				
Definition H (T:Type) := T -> T.

so [H.0] = lambda T, ([Pi] T (lambda _, T))
         : texp -> texp

   [H.1] = lambda T, lambda it, ?42
         : Pi T:texp, Pi it: (isatype T), (isatype ([H.0] T))

introduce a new constant

    [hold]

so that

    [hold] (lambda T, ([Pi] T (lambda _, T))) T

will represent the delayed application of [H.0] and be a texp.  Its type
has to be

           (texp -> texp) -> texp -> texp

So [hold] is the polymorphic identity function of type X -> X.  We could
even add the LF type to the constant, so we have an infinite family
of such constants.

    [hold;texp -> texp] (lambda T, ([Pi] T (lambda _, T))) T

I.e., we introduce expressions like

    [hold;t1 -> ... -> tn -> t] f x1 ... xn

and learn how to type it.  The type of [hold;X] is X->X.  Then we have
an infinite family of delta-reduction rules that reduce

    [hold;t1 -> ... -> tn -> t] f x1 ... xn

to

    f x1 ... xn

For printing purposes, we should add the name "H" somewhere:

    [hold;H,texp -> texp] (lambda T, ([Pi] T (lambda _, T))) T

=============================================================================

	Pi T:texp, istype T

Here "istype" is an atomic type family of kind texp -> type,
so that istype T is a type, and we can form the type 
Pi T:texp, istype T.  Now suppose we don't have type families,
but we do have singleton types and as many basetypes as we like.

We could write

   	Pi T:texp, .... S(T) ....

e.g.,

   	Pi T:texp, S(T)

   	Pi T:texp, Pi a:S(T), S(T).

   	Pi T:texp, Sigma a:S(T), S(T).


-----------------------------------------------------------------------------

Suppose we add singleton types to LF.  Then we make a definition, say

	Define foo ( T:Type ) := T -> T.

This leads to

       foo.0 = lambda T, ([Pi] T (lambda _, T))
       	     : Pi T:texp, texp

       foo.1 = lambda T, ??
       	     : Pi T:texp, isatype T

Having made that definition, we add new variables to the context:

       foo.0 : Singleton ( lambda T, ([Pi] T (lambda _, T)) ; Pi T:texp, texp )
       	     < Pi T:texp, texp


       foo.1 : Singleton ( lambda T, ?? ; Pi T:texp, isatype T )
       	     < Pi T:texp, isatype T

Now how does type checking go without unfolding?

Let's derive

	(hastype   ( [lambda] T (lambda x, x) )   ( foo.0 T )  )

First observe that

      	foo.0 : Pi T:texp, texp

so

	foo.0 T : texp

and just 


    	(hastype   ( [lambda] T (lambda x, x) )   ( foo.0 T )  ) : texp

(Is the idea that there is no unfolding during LF-type-checking?

We have both 


   	     		   foo.0 : Singleton ( lambda T, ([Pi] T (lambda _, T)) ; Pi T:texp, texp )

lambda T, ([Pi] T (lambda _, T)) : Singleton ( lambda T, ([Pi] T (lambda _, T)) ; Pi T:texp, texp )

so by (42) we have

   foo.0 = lambda T, ([Pi] T (lambda _, T))  :  Singleton ( lambda T, ([Pi] T (lambda _, T)) ; Pi T:texp, texp )

and thus

   foo.0 = lambda T, ([Pi] T (lambda _, T))  :  Pi T:texp, texp

So LF type checking can unfold if necessary.  When is it necessary?



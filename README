-*- coding: utf-8; fill-column: 87; mode: text; mode: auto-fill -*-

An attempt at making a toy proof checker for experimental purposes

This program encodes the type system TS developed in the paper "A universe
polymorphic type system", by Vladimir Voevodsky, the version dated October,
2012, and attempts to make a toy prototype proof assistant based on it.

Thanks to:

    Vladimir Voevodsky                  for TS and Univalence

    Andrej Bauer                        for advice about coding and
				        suggesting Logical Frameworks (LF) as the
				        way to go

    Bob Harper and Dan Licata           for explaining LF in an intuitive way

    Bob Harper and Christopher Stone    for the type checking algorithms used here

-----------------------------------------------------------------------------

Syntax, existing and proposed:

New syntactic class:

      TS "judgment" expressions that represent LF types

      		[ T type ]
		[ o : T ]
		[ T = U ]
		[ o = o' : T ]

     introduced by the Rule or Axiom command with :: (instead of : ).

New operators for TS format:

    /		left associative		TS form for TS substitution, translated
    					    	to LF application. 

    |->		right associative		TS arrow form for TS lambda and LF form
                       				for LF lambda.  Unicode: ↦ or ⟼

    =>		right associative		TS arrow form for LF Pi types.
    						Translated to LF -> .  Unicode: ⇒

    |=>		right associative		TS arrow form for LF lambda.
    						Translated to LF |-> .  Unicode: ⟾

    :		non-associative			TS and LF form for something having a
    						type.  But types in TS are objects in
    						LF, whereas judgments of TS are types in LF.

    ::		non-associative			TS format for expressing a derivation
						of a judgment. Translated to LF colon

    |-		non-associative			TS format for introducing the local
    						context for a judgment.  Unicode: ⊢

    { ... |- ... } =>				TS form corresponding to two parameters
    						in an LF Pi type.

Examples:

    f t                     LF evaluation in LF form

    f[t/x]                  LF evaluation in traditional form, not a good notation,
    			    because x should be considered bound in f 

    f/t                     LF evaluation in TS form



    lambda x, b             the LF lambda in LF form

    x |-> b                 the LF lambda in LF form

    x |=> b                 the LF lambda in TS form



    [lambda;x](f,o,U)       the TS lambda, in full TS form

    [lambda](f,o,x|=>U)     the TS lambda, in full TS form, an alternative

    lambda x:T, o           the TS lambda, in abbreviated TS form

    (x:T) |-> o             the TS lambda, in abbreviated TS form, proposed as an
    			    alternative 

    ([lambda] f o (x|->U))  the TS lambda, in full LF form



    [ev;x](f, t, U)         TS evaluation in full TS form

    [ev](f, t, x |=> U)     TS evaluation in full TS form

    f t                     TS evaluation in abbreviated TS form

    ([ev] f t (x |-> U))    TS evaluation in LF form



    T -> U                  the TS function type in TS form

    Pi x:T, U               the TS Pi in TS form, abbreviated

    [Pi;x](T,U)             the TS Pi in TS full form, to be revised

    [Pi](T,x |=> U)         the TS Pi in TS full form, proposed

    ([Pi] T (x |-> U)       the TS Pi in LF form



    A -> B                  LF function type in LF form

    A => B                  LF function type in TS form

    (x:T) -> U              the LF Pi in LF form

    Pi x:T, U               the LF Pi in LF form



    { |- T Type } ...       TS form for the LF type (T:(T1:texp) × istype T1) ⟶  ...

    { |-  b:U } ...         TS form for the LF type

    				(b : ((b:oexp) × hastype b T₁) ⟶ ...

    { x:T |- U Type } ...   TS form notation for LF

    				(U : (U:oexp ⟶ texp) × 
				     ((x:oexp) ⟶ hastype x T₁ ⟶
    				                 istype (U x))) 
				 -> ... 


    { x:T |- b:U } ...     TS form notation for LF type

				 ( b : ((b : oexp->oexp) -> ((x:oexp) -> (hastype x T) ->
				 (hastype (b x) (U x))) -> ... 

				 In other words, we think of b as introducing a pair of
				 variables.  To think of it as introducing one
				 variable, we could write this instead:

				    (b : Sigma b' : oexp -> oexp, (x:oexp) -> 
				    (hastype x T) -> (hastype (b' x) (U x))) -> ... 

-----------------------------------------------------------------------------

There's a problem on my screen with the width of the subscripted numerals.
They're 20% too wide:

    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
    MM₁₁₁₁MMMMMMMMMMMMMMMMM₁₁₁₁MMMMMMMM
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

C-H C-P gives this advice about that:

    *** Some of the fonts called for in your fontset may not exist on your
    X server.

    Each X11 font covers just a fraction of the characters that Emacs
    supports.  To display the whole range of Emacs characters requires
    many different fonts, collected into a fontset.  You can remedy the
    problem by installing additional fonts.

    The intlfonts distribution includes a full spectrum of fonts that can
    display all the characters Emacs supports.  The etl-unicode collection
    of fonts (available from <URL:ftp://ftp.x.org/contrib/fonts/> and
    <URL:ftp://ftp.xfree86.org/pub/mirror/X.Org/contrib/fonts/>) includes
    fonts that can display many Unicode characters; they can also be used
    by ps-print and ps-mule to print Unicode characters.

    ** Under X11, some characters appear improperly aligned in their lines.

    You may have bad X11 fonts; try installing the intlfonts distribution
    or the etl-unicode collection (see above).

-----------------------------------------------------------------------------

See

	ProofGeneral/lib/unicode-tokens.el

for an alternative to putting unicode into files.

-----------------------------------------------------------------------------

Definition parameters:


coq format		LF translation

T : Type		((T:texp) * (istype T))

t : T			((t:oexp) * (hastype t T))

X : T -> Type		((X:oexp->texp) * ((t : ((t:oexp) * (hastype t T))) -> (istype (X t)))

X : Type -> Type	((X:texp->texp) * ((T : ((T:texp) * (istype T))) -> (istype (X T))

-----------------------------------------------------------------------------

references:

Binary bidirectional algorithm for LF:
http://www.cs.cmu.edu/~rwh/papers/lf-theory/lf-theory.pdf

Simplest unifiication for first-order terms:
http://www.cs.cmu.edu/~fp/courses/lp/lectures/06-unif.pdf

Higher-order pattern unification
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.190.4789

-----------------------------------------------------------------------------

We need a pretty printer that can make something like this:

compose0'' = u ⟼ T ⟼ U ⟼ V ⟼ g ⟼ f ⟼ t ⟼ 
	     (pair 
	     	([ev] g₁ ([ev] f₁ t₁ (_ ⟼ ([El] U₁))) (_ ⟼ ([El] V₁))) 
		(ev_hastype 
		  (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
		  (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)) 
		  (pair g₁ (cast
		  	     (pair 
		  		([El] ([∀] u u U₁ (_ ⟼ V₁)) 
				(El_istype 
					u 
					(pair ([∀] u u U₁ (_ ⟼ V₁)) 
					      (forall u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂)))₂))₂) 
		   	     (pair ([∏] ([El] U₁) (_ ⟼ ([El] V₁))) 
			           (∏_istype (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
				   	     (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)))₂) 
			     (pair g₁ g₂) 
			     (El_forall_reduction u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂))))₂) 
		  (pair ([ev] f₁ t₁ (_ ⟼ ([El] U₁)))
		        (ev_hastype 
			    (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂)
			    (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)) 
			    (pair f₁ 
			          (cast (pair ([El] ([∀] u u T₁ (_ ⟼ U₁))) 
				  	      (El_istype 
					      	u 
					      	(pair 
						  ([∀] u u T₁ (_ ⟼ U₁)) 
						  (forall u u (pair T₁ T₂)
						  	      (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂)))₂))₂) 
				        (pair ([∏] ([El] T₁) (_ ⟼ ([El] U₁)))
					      (∏_istype (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂) 
					      	        (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)))₂) 
					(pair f₁ f₂) 
					(El_forall_reduction u u (pair T₁ T₂) (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂))))₂) 
			    (pair t₁ t₂))₂))₂)

an attempt at making a toy proof checker for experimental purposes

Inline long-form notation for definitions, proofs, and derivations, relative to the context
in effect in the term:

   Provisional: definitions involve lazy substitution from one context into another.
   		(we might also want lazy substitution within the same context)
       [udef;name](u1,...; u,...; eqn1,...;R)		here u is a universe level and we add [ name :: |- u : Univ ] to the context and return R
       [tdef;name](u1,...;T1,...;o1,...; T,R)		here T is a type and we add [ name :: |- T : Type ] to context and return R
       [odef;name](u1,...;T1,...; o,T,R)		here o is an object of type T and we add [ name :: |- o : T ] to the context

				
Definition H (T:Type) := T -> T.

so [H.0] = lambda T, ([Pi] T (lambda _, T))
         : texp -> texp

   [H.1] = lambda T, lambda it, ?42
         : Pi T:texp, Pi it: (isatype T), (isatype ([H.0] T))

introduce a new constant

    [hold]

so that

    [hold] (lambda T, ([Pi] T (lambda _, T))) T

will represent the delayed application of [H.0] and be a texp.  Its type
has to be

           (texp -> texp) -> texp -> texp

So [hold] is the polymorphic identity function of type X -> X.  We could
even add the LF type to the constant, so we have an infinite family
of such constants.

    [hold;texp -> texp] (lambda T, ([Pi] T (lambda _, T))) T

I.e., we introduce expressions like

    [hold;t1 -> ... -> tn -> t] f x1 ... xn

and learn how to type it.  The type of [hold;X] is X->X.  Then we have
an infinite family of delta-reduction rules that reduce

    [hold;t1 -> ... -> tn -> t] f x1 ... xn

to

    f x1 ... xn

For printing purposes, we should add the name "H" somewhere:

    [hold;H,texp -> texp] (lambda T, ([Pi] T (lambda _, T))) T


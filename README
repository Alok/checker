Examples of the syntax, existing and proposed:

    f t                     LF evaluation in LF form
    f[t/x]                  LF evaluation in traditional form, not a good notation, because x should be considered bound in f
    f//t                    LF evaluation in TS form, proposed

    x |-> b                 the LF lambda in LF form
    lambda x, b             the LF lambda in LF form
    x |- b                  the LF lambda in TS form, proposed

    [lambda;x](f,o,U)       the TS lambda, in full TS form, to be revised
    [lambda](f,o,x|-U)      the TS lambda, in full TS form, proposed
    lambda x:T, o           the TS lambda, in abbreviated TS form
    (x:T) |-> o             the TS lambda, in abbreviated TS form, proposed as an alternative
    ([lambda] f o (x|->U))  the TS lambda, in full LF form

    [ev;x](f, t, U)         TS evaluation in full TS form, to be revised
    [ev](f, t, x |- U)      TS evaluation in full TS form, proposed
    f t                     TS evaluation in abbreviated TS form
    ([ev] f t (x |-> U))    TS evaluation in LF form

    T -> U                  the TS function type in TS form
    Pi x:T, U               the TS Pi in TS form, abbreviated
    [Pi;x](T,U)             the TS Pi in TS full form, to be revised
    [Pi](T,x |- U)          the TS Pi in TS full form, proposed
    ([Pi] T (x |-> U)       the TS Pi in LF form

    A -> B                  LF function type in LF form
    A => B                  LF function type in TS form, proposed
    (x:T) -> U              the LF Pi in LF form, proposed as an alternative
    Pi x:T, U               the LF Pi in LF form
    [|- T Type] => ...      proposed TS form for LF
				    (T:texp) -> (i:istype T) -> ...
    [|- b:U] => ...         proposed TS form for LF
				    (b:oexp) -> (hastype b U) -> ...
    [x:T |- U Type] => ...  proposed TS form notation for LF
				    (U : oexp->texp) -> ((x:oexp) -> (h:hastype x T) -> (istype (U x))) -> ...
    [ x:T |- b:U ] => ...   proposed TS form notation for LF type
				    (b:oexp) -> ((x:oexp) -> (hastype x T) -> (hastype (f x) (U x))) -> ...

a rule in LF notation, currently parsable by the program:

Rule 27 beta_reduction : ∏ T : texp, ∏ U : oexp ⟶ texp, ∏ t : oexp, ∏ f : oexp ⟶ oexp,

     [ t : T ] ⟶ 

     (∏ x:oexp, [ x : T ] -> [ (f x) : (U x) ]) ⟶

     [ ([ev] ( [λ] T f ) t U) = (f t) : (U t) ].

the same rule in the proposed TS notation:

Rule 27 beta_reduction ::

     [ |- T Type ] =>

     [ x : T |- U Type ] =>

     [ |- t : T ] =>

     [ x : T |- b : U ] =>

     [ (lambda x:T, b) t = b//t : U//t ].

The last line above could be expanded to 

     [ [ev]( [lambda](T,x|-b), t, U//t ) = b//t : U//t ].

by the type checker, or written that way in full form.

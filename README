-*- coding: utf-8; fill-column: 87; mode: text; mode: auto-fill -*-

An attempt at making a toy proof checker for experimental purposes

This program encodes the type system TS developed in the paper "A universe
polymorphic type system", by Vladimir Voevodsky, the version dated October,
2012, and attempts to make a toy prototype proof assistant based on it.

Thanks to:

    Vladimir Voevodsky                  for TS and Univalence

    Andrej Bauer                        for advice about coding and
				        suggesting Logical Frameworks (LF) as the
				        way to go

    Bob Harper and Dan Licata           for explaining LF in an intuitive way

    Bob Harper and Christopher Stone    for the type checking algorithms used here

-----------------------------------------------------------------------------

Syntax, existing and proposed:

New syntactic class:

      TS "judgment" expressions that represent LF types

      		[ T type ]
		[ o : T ]
		[ T = U ]
		[ o = o' : T ]

     introduced by the Rule or Axiom command with :: (instead of : ).

New operators for TS format:

    /		left associative		TS form for TS substitution, translated
    					    	to LF application. 

    |->		right associative		TS arrow form for TS lambda and LF form
                       				for LF lambda.  Unicode: ↦ or ⟼

    =>		right associative		TS arrow form for LF Pi types.
    						Translated to LF -> .  Unicode: ⇒

    |=>		right associative		TS arrow form for LF lambda.
    						Translated to LF |-> .  Unicode: ⟾

    :		non-associative			TS and LF form for something having a
    						type.  But types in TS are objects in
    						LF, whereas judgments of TS are types in LF.

    ::		non-associative			TS format for expressing a derivation
						of a judgment. Translated to LF colon

    |-		non-associative			TS format for introducing the local
    						context for a judgment.  Unicode: ⊢

    { ... |- ... } =>				TS form corresponding to two parameters
    						in an LF Pi type.

Examples:

    f t                     LF evaluation in LF form

    f[t/x]                  LF evaluation in traditional form, not a good notation,
    			    because x should be considered bound in f 

    f/t                     LF evaluation in TS form



    lambda x, b             the LF lambda in LF form

    x |-> b                 the LF lambda in LF form

    x |=> b                 the LF lambda in TS form



    [lambda;x](f,o,U)       the TS lambda, in full TS form

    [lambda](f,o,x|=>U)     the TS lambda, in full TS form, an alternative

    lambda x:T, o           the TS lambda, in abbreviated TS form

    (x:T) |-> o             the TS lambda, in abbreviated TS form, proposed as an
    			    alternative 

    ([lambda] f o (x|->U))  the TS lambda, in full LF form



    [ev;x](f, t, U)         TS evaluation in full TS form

    [ev](f, t, x |=> U)     TS evaluation in full TS form

    f t                     TS evaluation in abbreviated TS form

    ([ev] f t (x |-> U))    TS evaluation in LF form



    T -> U                  the TS function type in TS form

    Pi x:T, U               the TS Pi in TS form, abbreviated

    [Pi;x](T,U)             the TS Pi in TS full form, to be revised

    [Pi](T,x |=> U)         the TS Pi in TS full form, proposed

    ([Pi] T (x |-> U)       the TS Pi in LF form



    A -> B                  LF function type in LF form

    A => B                  LF function type in TS form

    (x:T) -> U              the LF Pi in LF form

    Pi x:T, U               the LF Pi in LF form



    { |- T Type } ...       TS form for the LF type (T:(T1:texp) × istype T1) ⟶  ...

    { |-  b:U } ...         TS form for the LF type

    				(b : ((b:oexp) × hastype b T₁) ⟶ ...

    { x:T |- U Type } ...   TS form notation for LF

    				(U : (U:oexp ⟶ texp) × 
				     ((x:oexp) ⟶ hastype x T₁ ⟶
    				                 istype (U x))) 
				 -> ... 


    { x:T |- b:U } ...     TS form notation for LF type

				 ( b : ((b : oexp->oexp) -> ((x:oexp) -> (hastype x T) ->
				 (hastype (b x) (U x))) -> ... 

				 In other words, we think of b as introducing a pair of
				 variables.  To think of it as introducing one
				 variable, we could write this instead:

				    (b : Sigma b' : oexp -> oexp, (x:oexp) -> 
				    (hastype x T) -> (hastype (b' x) (U x))) -> ... 

-----------------------------------------------------------------------------

There's a problem on my screen with the width of the subscripted numerals.
They're 20% too wide:

    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
    MM₁₁₁₁MMMMMMMMMMMMMMMMM₁₁₁₁MMMMMMMM
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

C-H C-P gives this advice about that:

    *** Some of the fonts called for in your fontset may not exist on your
    X server.

    Each X11 font covers just a fraction of the characters that Emacs
    supports.  To display the whole range of Emacs characters requires
    many different fonts, collected into a fontset.  You can remedy the
    problem by installing additional fonts.

    The intlfonts distribution includes a full spectrum of fonts that can
    display all the characters Emacs supports.  The etl-unicode collection
    of fonts (available from <URL:ftp://ftp.x.org/contrib/fonts/> and
    <URL:ftp://ftp.xfree86.org/pub/mirror/X.Org/contrib/fonts/>) includes
    fonts that can display many Unicode characters; they can also be used
    by ps-print and ps-mule to print Unicode characters.

    ** Under X11, some characters appear improperly aligned in their lines.

    You may have bad X11 fonts; try installing the intlfonts distribution
    or the etl-unicode collection (see above).

-----------------------------------------------------------------------------

See

	ProofGeneral/lib/unicode-tokens.el

for an alternative to putting unicode into files.

-----------------------------------------------------------------------------

Definition parameters:


coq format		LF translation

T : Type		((T:texp) * (istype T))

t : T			((t:oexp) * (hastype t T))

X : T -> Type		((X:oexp->texp) * ((t : ((t:oexp) * (hastype t T))) -> (istype (X t)))

X : Type -> Type	((X:texp->texp) * ((T : ((T:texp) * (istype T))) -> (istype (X T))

-----------------------------------------------------------------------------

references:

Binary bidirectional algorithm for LF:
http://www.cs.cmu.edu/~rwh/papers/lf-theory/lf-theory.pdf

Simplest unifiication for first-order terms:
http://www.cs.cmu.edu/~fp/courses/lp/lectures/06-unif.pdf

Higher-order pattern unification
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.190.4789

-----------------------------------------------------------------------------

We need a pretty printer that can make something like this:

compose0'' = u ⟼ T ⟼ U ⟼ V ⟼ g ⟼ f ⟼ t ⟼ 
	     (pair 
	     	([ev] g₁ ([ev] f₁ t₁ (_ ⟼ ([El] U₁))) (_ ⟼ ([El] V₁))) 
		(ev_hastype 
		  (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
		  (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)) 
		  (pair g₁ (cast
		  	     (pair 
		  		([El] ([∀] u u U₁ (_ ⟼ V₁)) 
				(El_istype 
					u 
					(pair ([∀] u u U₁ (_ ⟼ V₁)) 
					      (forall u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂)))₂))₂) 
		   	     (pair ([∏] ([El] U₁) (_ ⟼ ([El] V₁))) 
			           (∏_istype (pair ([El] U₁) (El_istype u (pair U₁ U₂))₂) 
				   	     (pair (_ ⟼ ([El] V₁)) (_ ⟼ _ ⟼ (El_istype u (pair V₁ V₂))₂)))₂) 
			     (pair g₁ g₂) 
			     (El_forall_reduction u u (pair U₁ U₂) (pair (_ ⟼ V₁) (_ ⟼ _ ⟼ V₂))))₂) 
		  (pair ([ev] f₁ t₁ (_ ⟼ ([El] U₁)))
		        (ev_hastype 
			    (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂)
			    (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)) 
			    (pair f₁ 
			          (cast (pair ([El] ([∀] u u T₁ (_ ⟼ U₁))) 
				  	      (El_istype 
					      	u 
					      	(pair 
						  ([∀] u u T₁ (_ ⟼ U₁)) 
						  (forall u u (pair T₁ T₂)
						  	      (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂)))₂))₂) 
				        (pair ([∏] ([El] T₁) (_ ⟼ ([El] U₁)))
					      (∏_istype (pair ([El] T₁) (El_istype u (pair T₁ T₂))₂) 
					      	        (pair (_ ⟼ ([El] U₁)) (_ ⟼ _ ⟼ (El_istype u (pair U₁ U₂))₂)))₂) 
					(pair f₁ f₂) 
					(El_forall_reduction u u (pair T₁ T₂) (pair (_ ⟼ U₁) (_ ⟼ _ ⟼ U₂))))₂) 
			    (pair t₁ t₂))₂))₂)

-----------------------------------------------------------------------------

    I'm contemplating a change to the code having to do with the meaning we assign to
    premisses in inference rules.  Suppose the premise has the form

		    t : T |- x : U

    The usual meaning, as I understand it, is that we are given an expression x
    involving the variable t such that if t is of type T then it can be verified that x
    has type U.  (The verifier is represented in LF in my code by a term that accepts
    an expression t and a derivation that t has type T and returns a derivation that
    x(t) has type U(t).

    I'd like to consider switching to letting the premise mean that we are given an
    algorithm x that will convert a derivation that something has type T into a
    derivation that some new thing has type U.  (Of course, x will be represented by a
    term of LF.)

    It seems at first to be a weaker premise that would make the construction of proofs
    simpler, and I wonder whether it do any logical damage to adopt it.

    My intuition is that it will do no damage since we don't really care about
    ill-typed terms.

    More concretely, I think that from the term of LF representing the algorithm x we
    can always produce the corresponding term of TS: A derivation that something has
    type U is of sigma type where the first member of the pair is a term x' of TS and
    the second member of the pair is the derivation that x' has type U.  Take the term
    of LF, apply pi_1 in a context where t is of type T, and normalize.  The result
    will be a term of TS involving the variable t.  To prove that, one would observe
    that the inference rules of TS, whenever they assert that something has a type or
    that something is a type, the "something" is an explicitly given (inductively
    constructed) term of TS.

    It has to do with how we interpret what we mean by a proof of a theorem in a
    context where we have to stitch together a complete derivation tree.  Consider

    		Theorem A (t:T) : U.

    where U does not depend on t.  It could mean either

    	1)  A : ((t:oexp) × hastype t T) -> ((u:oexp) × hastype u U)

    or

	2)  A : (u : oexp->oexp) × ((t:oexp) -> (h:hastype t T) -> (hastype (u t) U)).

    Now consider how to compose the following two theorems to get a corollary:

    		Theorem A (t:T) : U.
    		Theorem B (u:U) : V.
		Corollary C (t:T) : V.

    The proof of C, depending on which case we're in, is:

    	   1)   t ⟼ B (A t)

    or

    	   2)   < t ⟼ B₁ (A₁ t)  ,  t ⟼ h ⟼ (B₂ (A₁ t) (A₂ t h)) >

    We prefer the simplicity of (1).

    It's nothing special about o-expressions, for the same remark applies to
    composition of definitions that accept a type and make a new type.

    compose3 : (u:uexp) ⟶ 
	    (T:(T1:oexp) × hastype T1 ([U] u)) ⟶ 
	    (U:(U1:oexp) × hastype U1 ([U] u)) ⟶ 
	    (V:(V1:oexp) × hastype V1 ([U] u)) ⟶ 
	    (g:oexp) × hastype g ([El] ([∀] u u U₁ (_ ⟼ V₁))) ⟶ 
	    (f:oexp) × hastype f ([El] ([∀] u u T₁ (_ ⟼ U₁))) ⟶ 
	    (t:oexp) × hastype t ([El] T₁) ⟶ 
	    (o:oexp) × hastype o ([El] V₁)

    compose3 u T U V g f t : 
	    (t:oexp) × hastype t ([El] T₁) ⟶ 
	    (o:oexp) × hastype o ([El] V₁)

    Now we want something of type

	    (o:oexp ⟶ oexp) × ( (x:oexp) ⟶ hastype x (El u T)₁ ⟶ hastype (o x) (El u V)₁)

    because the third argument in

            Axiom 3.4.23 λ_hastype { ⊢ T Type } { _ : T ⊢ U Type } { x : T ⊢ o : U/x } ⊢ [λ](T,o) : [∏](T,U).

    is declared with

            { x : T ⊢ o : U/x }

    which means 

	    o : (o1:oexp ⟶ oexp) × ((t:oexp) ⟶ hastype t T₁ ⟶ hastype (o1 t) (U₁ t))

    The idea is that this is too much for the inference rule to demand, and it should
    demand

	    o : (t : (t':oexp) × hastype t' T₁) ⟶ ((o':oexp) × hastype o' (U₁ t₁))

    instead, which is clearer.  But instead of

    	    U : (U1:oexp ⟶ texp) × ((t:oexp) ⟶ hastype t T₁ ⟶ istype (U1 t))

    we would also have 

	    U : (t':oexp) × hastype t' T₁  ⟶  (U':texp) × istype U'

    so we need to write

	    o : (t : (t':oexp) × hastype t' T₁) ⟶ ((o':oexp) × hastype o' (U t)₁)

    And then it would be convenient if hastype were redefined as

    	   hastype : (o:oexp) -> (T : (T':texp) × istype T') -> type

    , in which case we could write 

	    U : (t':oexp) × hastype t' T  ⟶  (U':texp) × istype U'

	    o : (t : (t':oexp) × hastype t' T) ⟶ ((o':oexp) × hastype o' (U t))

    , which would also be simpler.


    Hmm, but maybe there is a map

	    (t : (t':oexp) × hastype t' T₁) ⟶ ((o':oexp) × hastype o' (U₁ t₁))

	    	->

	    (o1:oexp ⟶ oexp) × ((t:oexp) ⟶ hastype t T₁ ⟶ hastype (o1 t) (U₁ t))

    Simplify to

	    (t : (t':oexp) × hastype t' T) ⟶ ((o':oexp) × hastype o' U)

	    	->

	    (o1:oexp ⟶ oexp) × ((t':oexp) ⟶ hastype t' T ⟶ hastype (o1 t') U)

    and just work on the first part:

	    (t : (t':oexp) × hastype t' T) ⟶ ((o':oexp) × hastype o' U)

	    	->

	    (o1:oexp ⟶ oexp)

    Nope.

\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amscd, amssymb}
\usepackage{enumerate}
\usepackage{mathtools}          %to get \vcentcolon

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parindent = 0.0in

\renewcommand{\thesubsection}{\arabic{subsection}}

\newenvironment{eq}{\begin{equation}}{\end{equation}}

\newenvironment{proof}{{\bf Proof}:}{\vskip 5mm }
\newenvironment{rem}{{\bf Remark}:}{\vskip 5mm }
\newenvironment{remarks}{{\bf Remarks}:\begin{enumerate}}{\end{enumerate}}
\newenvironment{examples}{{\bf Examples}:\begin{enumerate}}{\end{enumerate}}  

\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{definition}[proposition]{Definition}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{cor}[proposition]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{pretheorem}[proposition]{Pretheorem}
\newtheorem{hypothesis}[proposition]{Hypothesis}
\newtheorem{example}[proposition]{Example}
\newtheorem{remark}[proposition]{Remark}
\newtheorem{ex}[proposition]{Exercise}
\newtheorem{cond}[proposition]{Conditions}
\newtheorem{cons}[proposition]{Construction}

%\newcommand{\C}[4]{\left[\begin{array}{rcl}&#1\\#3&\dw\dw&#4\\&#2\end{array}\right]}
\newcommand{\llabel}[1]{\label{#1}[{\bf #1}]}
%\newcommand{\llabel}[1]{\label{#1}}
\newcommand{\comment}[1]{}
\newcommand{\sr}{\rightarrow}
\newcommand{\lr}{\longrightarrow}
\newcommand{\xr}{\xrightarrow}
\newcommand{\dw}{\downarrow}
\newcommand{\bdl}{\bar{\Delta}}
\newcommand{\zz}{{\bf Z\rm}}
\newcommand{\zq}{{\bf Z}_{qfh}}
\newcommand{\nn}{{\bf N\rm}}
\newcommand{\qq}{{\bf Q\rm}}
\newcommand{\nq}{{\bf N}_{qfh}}
\newcommand{\oo}{\otimes}
\newcommand{\uu}{\underline}
\newcommand{\ih}{\uu{Hom}}
\newcommand{\af}{{\bf A}^1}
\newcommand{\wt}{\widetilde}
\newcommand{\gm}{{\bf G}_m}
\newcommand{\dsr}{\stackrel{\sr}{\scriptstyle\sr}}
%\newcommand{\PP}{$P_{\infty}$}
\newcommand{\tp}{\tilde{D}}
\newcommand{\HH}{$H_{\infty}$}
\newcommand{\ii}{\stackrel{\scriptstyle\sim}{\sr}}
\newcommand{\BB}{_{\bullet}}
\newcommand{\D}{\Delta}
\newcommand{\colim}{{\rm co}\hspace{-1mm}\lim}
\newcommand{\cf}{{\it cf} }
\newcommand{\msf}{\mathsf }
\newcommand{\mcal}{\mathcal }
\newcommand{\ep}{\epsilon}
\newcommand{\tl}{\widetilde}
\newcommand{\ub}{\mbox{\rotatebox{90}{$\in$}}}
\newcommand{\ssp}{\,\,\,\,\,\,\,\,}
\newcommand{\red}{\twoheadrightarrow}
\newcommand{\eqg}{\stackrel{\Gamma}{\approx}}
\newcommand{\alphaeq}{\stackrel{\alpha}{\sim}}
\newcommand{\rtr}{\triangleright}

\newcommand{\piece}{\vskip 3mm\noindent\refstepcounter{proposition}{\bf
\theproposition}\hspace{2mm}}
\newcommand{\subpiece}{\vskip 3mm\noindent\refstepcounter{equation}{\bf\theequation}
\hspace{2mm}}{\vskip
3mm}

%% \newcommand{\ev}{{\bf ev}}
\newcommand{\TT}{{\bf Type0}}
\newcommand{\PP}{{\bf Prop}}
\newcommand{\cc}{{\bf c}}
\newcommand{\rect}{{\bf rect}}
\newcommand{\eqd}{\stackrel{d}{=}}

\newcommand{\cu}{{u}}
\newcommand{\Eu}{{\cal U}}
\newcommand{\JJ}[2]{{J(#1,#2)\,}}
\newcommand{\J}[1]{{J(#1)\,}}
\newcommand{\jj}[3]{{j(#1,#2,#3)\,}}
\newcommand{\jr}[2]{{jr(#1, #2)\,}}
\newcommand{\jl}[2]{{jl(#1, #2)\,}}
\newcommand{\UU}[1]{{UU(#1)}}
\newcommand{\rd}{\succ}
\newcommand{\rde}{\succeq}
\newcommand{\rdA}{\rd_{\AA}}
\newcommand{\brd}{\equiv}
\newcommand{\ind}{Ind\,\,}
\newcommand{\erd}[1]{\equiv_{{\AA},#1}}
\newcommand{\spc}{{\,\,\,\,\,\,\,}}
\renewcommand{\AA}{{\cal A}}

\newcommand{\ccolon}[1]{\vcentcolon#1}
\newcommand{\synth}[1]{\vcentcolon(\Rightarrow#1)} %\Rightarrow
\newcommand{\ccheck}[1]{\vcentcolon#1}  %\Leftarrow

\newcommand{\Type}{\mathop{\text{ \sc type}}}
\newcommand{\Okay}{\mathop{\text{ \sc okay}}}
\newcommand{\ha}[2]{#1[#2]}
\newcommand{\Wrefl}{{\sf Wrefl}}
\newcommand{\weta}{{\sf weta}}
\newcommand{\Wtrans}{{\sf Wtrans}}
\newcommand{\Wsymm}{{\sf Wsymm}}
\newcommand{\El}{{\sf El}}
\newcommand{\annot}{{\sf annot}}
\newcommand{\conv}{{\sf conv}}
\newcommand{\ev}{{\sf ev}}
\newcommand{\wbeta}{{\sf wbeta}}
\newcommand{\weleq}{{\sf weleq}}
\newcommand{\weveq}{{\sf weveq}}
\newcommand{\wl}{{\sf wl}}
\newcommand{\wpi}{{\sf wpi}}
\newcommand{\wsrefl}{{\sf wsrefl}}
\newcommand{\wcrefl}{{\sf wcrefl}}
\newcommand{\wssymm}{{\sf wssymm}}
\newcommand{\wcsymm}{{\sf wcsymm}}
\newcommand{\wstrans}{{\sf wstrans}}
\newcommand{\wctrans}{{\sf wctrans}}
\newcommand{\var}{\char`_}
\newcommand{\defn}{\vcentcolon=}

\begin{document}

\parskip = 2mm
\begin{center}
{\bf\Large A test type system}

{\bf Vladimir Voevodsky}

{Started January 25, 2013}  

{This version modified by Dan Grayson}  
\end{center}

\tableofcontents

This note gives some ideas about the test type system TTS with secondary
witnessed which Dan Grayson and I have been working on implementing. While TTS
by itself has (most likely) decidable definitional equality and typing making
secondary witnesses to be formally speaking unnecessary, they become essential
for the implementation of more complex systems with undecidable typing such as
HTS.

We are aiming at a type system where every derivable extended sentence can be
obtained by a unique inference rules such that one gets a bijection between
inference trees and $\alpha$-equivalence classes of derivable extended
sentences.

\subsection{Rules}

A {\em sentence} has one of the following forms:

$$\Gamma\vdash \Okay$$
$$\Gamma\vdash T \Type$$
$$\Gamma\vdash o \ccolon{T}$$
$$\Gamma\vdash p : T \eqd T'$$
$$\Gamma\vdash p : t \eqd t' \ccolon{T}$$

where $p$, $o$, $t$, $t'$, $T$, $T'$ are expressions with free variables {\em
  introduced} by $\Gamma$.  Here $\Gamma$ is a {\em context}, a list of items,
each of which has one of the following forms:

$$\{ \Gamma'\vdash X \Type \}$$
$$\{ \Gamma'\vdash X \defn T \Type \}$$

$$\{ \Gamma'\vdash x \ccolon{T} \}$$
$$\{ \Gamma'\vdash x \defn o \ccolon{T} \}$$

$$\{ \Gamma'\vdash w : T \eqd T'\}$$
$$\{ \Gamma'\vdash w \defn p : T \eqd T'\}$$

$$\{ \Gamma'\vdash w : t \eqd t' \ccolon{T} \}$$
$$\{ \Gamma'\vdash w \defn p : t \eqd t' \ccolon{T} \}$$

where $\Gamma'$ is a context, where $T$, $T'$, $t$, and $t'$ are expressions
with free variables introduced by $\Gamma'$ or by earlier entries in the list
$\Gamma$, and where $X$, $x$, or $w$ is the (single) variable {\em introduced}
by the item.  The operator $\defn$ is used to indicate that the variable is
accompanied by a value, thereby providing a definition, rather than an axiom.

If $\Gamma'$ is empty, we may simplify notation and write
$$ X \Type $$
for
$$\{ \Gamma'\vdash X \Type \}$$
and
$$x \ccolon{T}$$
for
$$\{ \Gamma'\vdash x \ccolon{T} \},$$
etc., in $\Gamma$.

Inference rules given later determine which sentences are well-formed and
derivable.

Variables in the context are considered to be nameless and distinct.  To
emphasize that, we may write the names of all the variables as underscores, as
in $\var \ccolon{T_1},\dots,\var \ccolon{T_n}\vdash \Okay$.

In the inference rules below, we'll indicate directionality of type inference
in our algorithms by writing 
$$\Gamma\vdash o \synth{T}$$ to indicate that the type $T$ is produced
from the term $o$ and the rest of the information in the sentence by the
algorithms, whereas in $$\Gamma\vdash o \ccheck{T}$$ the type $T$ is known and
the task is to check that $o$ is of type $T$.  In the former case, one says
that $o$ synthesizes its type, and in the latter case, that the type of $o$ is
to be checked.  Such directional indications are used for ease of thinking
about the correctness, description, and implementation of the algorithms.  The
algorithms will necessarily be directional, in that some parts of them will be
asked to check that an object has a given type, and other parts of which will
be asked to manipulate objects whose type has already been determined.

{\bf Warning}: We intend for certain metatheoretical implications between
judgments to hold.  For example, we expect $\Gamma \vdash p : t \eqd t'
\synth{T}$ would imply that $\Gamma \vdash t \synth{T}$, $\Gamma \vdash t'
\synth{T}$, and $\Gamma \vdash T \Type$, hold, in the sense that the algorithms
described below succeed in checking the statements.

Thanks to Dan Licata for suggestions and advice.

\paragraph{Inference rules} 

\begin{enumerate}

\item
$$\frac{}{\vdash\Okay}$$

\item
$$\frac{\Gamma,\Gamma'\vdash \Okay}{\Gamma,\{\Gamma' \vdash X \Type \} \vdash\Okay}$$

This item introduces a variable $X$ representing a family of types parametrized by
the variables of $\Gamma'$.  It is intended only for temporary use.

\item
$$\frac{\Gamma,\Gamma'\vdash T \Type }{\Gamma,\{\Gamma' \vdash X \defn T \Type \} \vdash\Okay}$$

This item introduces a variable $X$ representing a family of types parametrized by
the variables of $\Gamma'$, with value is given by the expression $T$.  This is
intended to be the standard way that type families, such as $\mathop{isProp}$,
are defined.

\item
$$\frac{\Gamma,\Gamma'\vdash T \Type}{\Gamma,\{\Gamma' \vdash x \ccolon{T} \} \vdash\Okay}$$

This item introduces a variable $x$ of type $T$.  Both are parametrized by the
variables of $\Gamma'$.  This would be the standard way to introduce a type $T$
as an axiom.

\item
$$\frac{\Gamma,\Gamma'\vdash o \synth T}{\Gamma,\{\Gamma' \vdash x \defn o \ccolon{T} \} \vdash\Okay}$$

This item introduces a variable $x$ with value $o$ of type $T$. This would be
the standard way to record the proof $o$ of a theorem $T$ parametrized by
$\Gamma'$ under the name $x$.

\item
$$\frac{\Gamma,\Gamma'\vdash T \Type \spc \Gamma,\Gamma'\vdash T' \Type}{\Gamma,\{\Gamma' \vdash w : T \eqd T' \} \vdash\Okay}$$

This item introduces an axiom asserting equality of $T$ and $T'$ under the name $w$.

\item
$$\frac{\Gamma,\Gamma'\vdash p : T \eqd T' \Type}{\Gamma,\{\Gamma' \vdash w \defn p : T \eqd T' \} \vdash\Okay}$$

This item records, under the name $w$, a proof $p$ for equality of $T$ and $T'$.

\item
$$\frac{\Gamma,\Gamma'\vdash T \Type,~ t \synth{T},~ t' \synth{T}}{\Gamma,\{\Gamma' \vdash w : t \eqd t' \ccolon{T} \} \vdash\Okay}$$

This item introduces an axiom asserting equality of $t$ and $t'$ under the name $w$.

\item
$$\frac{\Gamma,\Gamma'\vdash p : t \eqd t' \synth{T} }{\Gamma,\{\Gamma' \vdash w \defn p : t \eqd t' \ccolon{T} \} \vdash\Okay}$$

This item records, under the name $w$, a proof $p$ for equality of $t$ and $t'$ of type $T$, parametrized by $\Gamma'$.

\item 
If $\{ \Gamma' \vdash x : T \}$ occurs in $\Gamma$, then
$$\frac{\Gamma\vdash u \ccheck \Gamma'}{\Gamma\vdash x[u] \synth{T[u]}}$$

Here $u \ccheck \Gamma'$ indicates that $u$ is a sequence of terms in the
context $\Gamma$ satisfiying the types in $\Gamma'$, and $x[u]$ denotes the
result of substitution of $u$ for the parameters of $x$..  It remains to write
rules clarifying the meaning of that.

The implicit algorithm here fires when the code detects that the head of the
expression is a variable.

Similarly for the other types of sentence.

\item 
$$\frac{\Gamma \vdash T \Type\spc \Gamma \vdash T'\Type \spc T\sim T'}{\Gamma\vdash \ha\Wrefl{}: T\eqd T'}$$

Here $T\sim T'$ denotes a comparison operation on terms, which treats certain
conversion and annotation operations specially, as mentioned below.

If $T'$ is obtained from $T$ by removing conversions, it may not be possible to apply
this rule because $T'$ may not be validatable.  Similarly for objects.

\item 
$$\frac{\Gamma\vdash p:T_1\eqd T_2}{\Gamma\vdash \ha\Wsymm{p}:T_2\eqd T_1}$$

\item 
$$\frac{\Gamma\vdash p:T_1\eqd T_2\spc\Gamma\vdash q:T_2\eqd T_3}{\Gamma\vdash \ha\Wtrans{p,q,T_2}: T_1\eqd T_3}$$

\item 
$$\frac{\Gamma\vdash o \synth{T}\spc\Gamma\vdash o' \synth{T} \spc o \sim o'}{\Gamma\vdash \ha\wsrefl{}:o\eqd o' \synth{T}}$$

\item 
$$\frac{\Gamma\vdash o \ccheck{T}\spc\Gamma\vdash o' \ccheck{T} \spc o \sim o'}{\Gamma\vdash \ha\wcrefl{}:o\eqd o' \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \synth{T}}{\Gamma\vdash \ha\wssymm{p}:o_2\eqd o_1 \synth{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \ccheck{T}}{\Gamma\vdash \ha\wcsymm{p}:o_2\eqd o_1 \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \synth{T}\spc\Gamma\vdash q:o_2\eqd o_3 \synth{T}}{\Gamma\vdash \ha\wstrans{p,q,o_2}:o_1\eqd o_3 \synth{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \ccheck{T}\spc\Gamma\vdash q:o_2\eqd o_3 \ccheck{T}}{\Gamma\vdash \ha\wctrans{p,q,o_2}:o_1\eqd o_3 \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash o \synth{T}\spc \Gamma\vdash q : T \eqd T'}{\Gamma\vdash \ha\conv{o,q} \ccheck{T'}}$$

In the comparisons $T\sim T'$ and $o\sim o'$, the term $\ha\conv{o,T,q}$ is regarded as equivalent to $o$.

\item 
$$\frac{\Gamma\vdash o \ccheck{T}}{\Gamma\vdash \ha\annot{o,T} \synth{T}}$$

In the comparisons $T\sim T'$ and $o\sim o'$, the term $\ha\annot{o,T}$ is regarded as equivalent to $o$.

In the code, the term $\ha\annot{o,T}$ could be represented by a private data
type, so that such terms can be created only by the kernel of the type checker,
and so no tactic could forge such a certificate.

\end{enumerate}

\paragraph{Universe}

\begin{enumerate}

\item for $x$ not in $v(\Gamma)$

$$\frac{\Gamma\vdash\Okay}{\Gamma \vdash \Eu\Type}$$

\item for $x$ not in $v(\Gamma)$

$$\frac{\Gamma\vdash o \synth{\Eu}}{\Gamma \vdash \ha\El{o}\Type}$$

Later on, there will a universe level, and it will be computable from the
term $o$, hence the choice of direction in this rule.

\item 

$$\frac{\Gamma\vdash p : o \eqd o' \synth{\Eu}}{\Gamma\vdash \ha\weleq{p} : \ha\El{o} \eqd \ha\El{o'}}$$

\end{enumerate}

\paragraph{Dependent products}

\begin{enumerate}

\item 
$$\frac{\Gamma, \var \ccolon{T}\vdash U\Type}{\Gamma\vdash \ha\prod{T,.U}\Type}$$

Here $.U$ is notation for abstraction: binding a variable to the scope of the expression $U$.

\item 
$$ \frac{ 
  \Gamma, \var \ccolon{T'} \vdash U'  \Type      \spc 
  \Gamma     \vdash p:T \eqd T'    \spc
  \Gamma,  \var \ccolon{T}  \vdash q:U \eqd p^*U'
  } {
  \Gamma     \vdash \ha\wpi{p,q}:\ha\prod{T,.U}\eqd \ha\prod{T',.U'}
}$$

Here ${p}^*U'$ is notation for $U'[\ha\annot{\ha\conv{\#0,p},T'}/\#0]$, where
$U'[e/\#0]$ is notation for replacing the first variable in $U'$ by $e$, and
where any $\#0$ occuring in $e$ denotes the first variable in the resulting
term.

\item 
$$\frac{\Gamma, \var \ccolon{T}\vdash o \ccheck{U}}{\Gamma\vdash \ha\lambda{.o} \ccheck{\ha\prod{T,.U}}}$$

Some space is saved by not annotating $\ha\lambda{.o}$ with $T$ and $.U$, due to bidirectionality.

\item 
$$\frac{\Gamma, \var \ccolon{T}\vdash p : o\eqd o' \ccheck{U}}{\Gamma\vdash \ha\wl{p} : \ha\lambda{.o}\eqd \ha\lambda{.o'} : \ha\prod{T,.U}}$$

\item 
$$\frac{\Gamma\vdash f \ccolon{\ha\prod{T,.U}}\spc \Gamma\vdash t \ccheck{T}}{\Gamma\vdash \ha\ev{f,t} \synth{U[\ha\annot{t,T}]}}$$

Here $U[o]$ is notation for replacing the first variable of $U$ by $o$, with
the second variable of $U$ becoming the first, and so on.  

The annotation is present to ensure that the sentence $\Gamma \vdash
U[\ha\annot{t,T}] \Type$ is checkable.

Some space is saved by not annotating $\ha\ev{f,o}$ with $T$ and $.U$, due to
bidirectionality.  The same applies to such expressions as $x.y.z.f\, x\, y\,
z$, where $f$ synthesizes its type.

\item 
$$\frac{
   \Gamma\vdash p : f \eqd f' \synth{\ha\prod{T,.U}}\spc 
   \Gamma\vdash q : t \eqd t' \ccheck{T}
   }{
   \Gamma\vdash \ha\weveq{p,q} : \ha\ev{f,t} \eqd \ha\ev{f',t'} \synth{U[\ha\annot{t,T}]}
  }$$

For simplicity, assume that $f'$ is $f$, and observe that $\Gamma \vdash
\ha\ev{f',t'} \synth{U[\ha\annot{t,T}]}$ may not be valid, even though $\Gamma
\vdash \ha\ev{f',t'} \synth{U[\ha\annot{t',T}]}$ is.  Nevertheless, $\Gamma \vdash
\ha\ev{f',t'} : U[\ha\annot{t,T}]$ is valid in the underlying type theory where
the witnesses have been forgotten.

\item 
% beta
$$\frac{ \Gamma\vdash t \ccheck{T}\spc \Gamma, \var \ccolon{T}\vdash u \ccheck{U}}{\Gamma\vdash \ha\wbeta{T,.U} : \ha\ev{\ha\lambda{.u},t} \eqd u[\ha\annot{t,T}] : U[\ha\annot{t,T}]}$$

Replacing $\ha\lambda{.u}$ by $\ha\annot{\ha\lambda{.u},\ha\prod{T,.U}}$ would
be an alternative to putting $T$ and $.U$ in the witness.  Comparison of two
terms of the same type by normalization need not involve computation of the
types of partially applied results, so a version of this rule free of type
annotations is needed.
% eta

\item 
$$\frac{\Gamma\vdash f \ccheck{\ha\prod{T,.U}}}{\Gamma\vdash \ha\weta{} : f \eqd \ha\lambda{x.\ha\ev{f,x}} : \ha\prod{T,.U}}$$ 

\end{enumerate}

\bibliography{alggeom}
\bibliographystyle{plain}
\end{document}
  %% Local Variables:
  %% compile-command: "pdflatex TTS-internal-witnesses.tex "
  %% End:

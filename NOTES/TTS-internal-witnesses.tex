\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amscd, amssymb}
\usepackage{enumerate}
\usepackage{mathtools}          %to get \vcentcolon
\usepackage{mathpartir}

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parindent = 0.0in

\renewcommand{\thesubsection}{\arabic{subsection}}

\newenvironment{eq}{\begin{equation}}{\end{equation}}

\newenvironment{proof}{{\bf Proof}:}{\vskip 5mm }
\newenvironment{rem}{{\bf Remark}:}{\vskip 5mm }
\newenvironment{remarks}{{\bf Remarks}:\begin{enumerate}}{\end{enumerate}}
\newenvironment{examples}{{\bf Examples}:\begin{enumerate}}{\end{enumerate}}  

\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{definition}[proposition]{Definition}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{cor}[proposition]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{pretheorem}[proposition]{Pretheorem}
\newtheorem{hypothesis}[proposition]{Hypothesis}
\newtheorem{example}[proposition]{Example}
\newtheorem{remark}[proposition]{Remark}
\newtheorem{ex}[proposition]{Exercise}
\newtheorem{cond}[proposition]{Conditions}
\newtheorem{cons}[proposition]{Construction}

%\newcommand{\C}[4]{\left[\begin{array}{rcl}&#1\\#3&\dw\dw&#4\\&#2\end{array}\right]}
\newcommand{\llabel}[1]{\label{#1}[{\bf #1}]}
%\newcommand{\llabel}[1]{\label{#1}}
\newcommand{\comment}[1]{}
\newcommand{\sr}{\rightarrow}
\newcommand{\lr}{\longrightarrow}
\newcommand{\xr}{\xrightarrow}
\newcommand{\dw}{\downarrow}
\newcommand{\bdl}{\bar{\Delta}}
\newcommand{\zz}{{\bf Z\rm}}
\newcommand{\zq}{{\bf Z}_{qfh}}
\newcommand{\nn}{{\bf N\rm}}
\newcommand{\qq}{{\bf Q\rm}}
\newcommand{\nq}{{\bf N}_{qfh}}
\newcommand{\oo}{\otimes}
\newcommand{\uu}{\underline}
\newcommand{\ih}{\uu{Hom}}
\newcommand{\af}{{\bf A}^1}
\newcommand{\wt}{\widetilde}
\newcommand{\gm}{{\bf G}_m}
\newcommand{\dsr}{\stackrel{\sr}{\scriptstyle\sr}}
%\newcommand{\PP}{$P_{\infty}$}
\newcommand{\tp}{\tilde{D}}
\newcommand{\HH}{$H_{\infty}$}
\newcommand{\ii}{\stackrel{\scriptstyle\sim}{\sr}}
\newcommand{\BB}{_{\bullet}}
\newcommand{\D}{\Delta}
\newcommand{\colim}{{\rm co}\hspace{-1mm}\lim}
\newcommand{\cf}{{\it cf} }
\newcommand{\msf}{\mathsf }
\newcommand{\mcal}{\mathcal }
\newcommand{\ep}{\epsilon}
\newcommand{\tl}{\widetilde}
\newcommand{\ub}{\mbox{\rotatebox{90}{$\in$}}}
\newcommand{\ssp}{\,\,\,\,\,\,\,\,}
\newcommand{\red}{\twoheadrightarrow}
\newcommand{\eqg}{\stackrel{\Gamma}{\approx}}
\newcommand{\alphaeq}{\stackrel{\alpha}{\sim}}
\newcommand{\rtr}{\triangleright}

\newcommand{\piece}{\vskip 3mm\noindent\refstepcounter{proposition}{\bf
\theproposition}\hspace{2mm}}
\newcommand{\subpiece}{\vskip 3mm\noindent\refstepcounter{equation}{\bf\theequation}
\hspace{2mm}}{\vskip
3mm}

\newcommand{\TT}{{\bf Type0}}
\newcommand{\PP}{{\bf Prop}}
\newcommand{\cc}{{\bf c}}
\newcommand{\rect}{{\bf rect}}
\newcommand{\eqd}{\equiv}

\newcommand{\cu}{{u}}
\newcommand{\Univ}{{\cal U}}
\newcommand{\FUniv}{{\cal U}^F}
\newcommand{\JJ}[2]{{J(#1,#2)\,}}
\newcommand{\J}[1]{{J(#1)\,}}
\newcommand{\jj}[3]{{j(#1,#2,#3)\,}}
\newcommand{\jr}[2]{{jr(#1, #2)\,}}
\newcommand{\jl}[2]{{jl(#1, #2)\,}}
\newcommand{\UU}[1]{{UU(#1)}}
\newcommand{\rd}{\succ}
\newcommand{\rde}{\succeq}
\newcommand{\rdA}{\rd_{\AA}}
\newcommand{\brd}{\equiv}
\newcommand{\ind}{Ind\,\,}
\newcommand{\erd}[1]{\equiv_{{\AA},#1}}
\renewcommand{\AA}{{\cal A}}

\newcommand{\ccolon}{\vcentcolon}
\newcommand{\ccheck}{\vcentcolon}            % was \Leftarrow
\newcommand{\csynth}{\vcentcolon\vcentcolon} % was \Rightarrow
\renewcommand{\csynth}{\ccheck}              % was \Rightarrow

\newcommand{\UNIV}{\mathop{\text{ \sc univ}}}
\newcommand{\TYPE}{\mathop{\text{ \sc type}}}
\newcommand{\FTYPE}{\mathop{\text{ \sc ftype}}}
\newcommand{\Type}{\mathop{\text{Type}}}
\newcommand{\Okay}{\mathop{\text{ \sc okay}}}
\newcommand{\Context}{\vdash\Okay}
\renewcommand{\Context}{\vdash}
\newcommand{\ha}[2]{#1[#2]}
\newcommand{\Wrefl}{{\sf Wrefl}}
\newcommand{\weta}{{\sf weta}}
\newcommand{\Wtrans}{{\sf Wtrans}}
\newcommand{\Wsymm}{{\sf Wsymm}}
\newcommand{\El}{{\sf El}}
\newcommand{\ElF}{{\sf El}^F}
\newcommand{\tprod}{\Pi}
\newcommand{\annot}{{\sf annot}}
\newcommand{\haa}[2]{\ha\annot{#1,#2}}
\renewcommand{\haa}[2]{#1}
\newcommand{\conv}{{\sf conv}}
\newcommand{\univinc}{{\sf j}}
\newcommand{\wconv}{{\sf wconv}}
\newcommand{\ev}{{\sf ev}}
\newcommand{\wbeta}{{\sf wbeta}}
\newcommand{\weleq}{{\sf weleq}}
\newcommand{\welfeq}{{\sf welfeq}}
\newcommand{\weveq}{{\sf wev}}
\newcommand{\wlambda}{{\sf wlambda}}
\newcommand{\Wsubst}{{\sf Wsubst}}
\newcommand{\wsubst}{{\sf wsubst}}
\newcommand{\wpieq}{{\sf wpi}}
\newcommand{\wrefl}{{\sf wrefl}}
\newcommand{\wsymm}{{\sf wsymm}}
\newcommand{\wtrans}{{\sf wtrans}}
\newcommand{\windo}{{\sf windo}}
\newcommand{\windeq}{{\sf windeq}}
\newcommand{\winds}{{\sf winds}}
\newcommand{\wetaN}{{\sf wetaN}}
\newcommand{\wetatN}{{\sf wetatN}}
\newcommand{\succN}{{\sf succ}}
\newcommand{\zeroN}{{\sf zero}}
\newcommand{\var}{\char`_}
\newcommand{\defn}{\vcentcolon\equiv}
\newcommand{\NN}{\mathbb N}
\newcommand{\indN}{{\sf ind}_\NN}
\newcommand{\indtN}{{\sf indt}_\NN}

\begin{document}

\parskip = 2mm
\begin{center}
{\bf\Large A test type system}

{\bf Vladimir Voevodsky}

{Started January 25, 2013}  

{This version modified heavily by Dan Grayson}  
\end{center}

\tableofcontents

This note gives some ideas about the test type system TTS with secondary
witnessed which Dan Grayson and I have been working on implementing. While TTS
by itself has (most likely) decidable definitional equality and typing making
secondary witnesses to be formally speaking unnecessary, they become essential
for the implementation of more complex systems with undecidable typing such as
HTS.

We are aiming at a type system where every derivable extended sentence can be
obtained by a unique inference rules such that one gets a bijection between
inference trees and $\alpha$-equivalence classes of derivable extended
sentences.  The extension is chosen here in a minimal way.

\subsection{Rules}

A {\em supertype} $J$ has one of the following forms:

$$ u \UNIV $$
$$ u \defn n \UNIV $$
$$ X \TYPE $$
$$ X \defn T \TYPE $$
$$ X \FTYPE $$
$$ X \defn T \FTYPE $$
$$ x \ccolon T $$
$$ x \defn t \ccolon T $$
$$ w : T \eqd T' $$
$$ w \defn p : T \eqd T' $$
$$ w : t \eqd t' \ccolon T \eqd T' $$
$$ w \defn p : t \eqd t' \ccolon T \eqd T' $$
%% $$ v : J \Rightarrow J' $$

where $U$, $X$, $v$, $x$, or $w$ is the (single) variable {\em introduced} by
the supertype, where $n$, $p$, $t$, $t'$, $T$, $T'$ are expressions, possibly
with free variables, that define values for the variables (as indicated by the
operator $\defn$).
%% , and where $J$ and $J'$ are supertypes.  The variable
%% introduced by $J$ is regarded as bound in $J'$. The variable introduced by
%% $J'$ is unused in $ v : J \Rightarrow J' $; we write $ J \Rightarrow J' $ to
%% indicate re-using it to serve as $v$.

A {\em context} or {\em sentence} $\Gamma$ is a list of supertypes, each of
which has all of its free variables bound by variables introduced earlier in
the list.  Alternatively, we may say the variable introduced by a supertype in
the list is bound in the remainder of the list.

The witnesses $w$ and $p$ are the additional data that makes these sentences
{\em extended}, and need be recorded only if the derivation tree needs to
recoverable from the derived sentence.

Inference rules given later determine which sentences are well-formed and
derivable.  The notation $$\Gamma \Context$$ will be used to indicate that
$\Gamma$ is well-formed.

Equality between expressions occurring twice in the conclusion of an inference
rule will be up to renaming of local variables and expansion of definitions.

The last variable introduced by a context is unused, so if it has a defined
value, we may abbreviate the corresponding sentence moving the last entry to
the right of the turnstile, without its variable.  In other words, we may
abbreviate the six sentences

$$ \Gamma, u \defn n \UNIV \Context $$
$$ \Gamma, X \defn T \TYPE \Context $$
$$ \Gamma, X \defn T \FTYPE \Context $$
$$ \Gamma, x \defn t \ccolon T \Context $$
$$ \Gamma, w \defn p : T \eqd T' \Context $$
$$ \Gamma, w \defn p : t \eqd t' \ccolon T \eqd T' \Context $$

by the following sentences:

$$ \Gamma \vdash n \UNIV $$
$$ \Gamma \vdash T \TYPE $$
$$ \Gamma \vdash T \FTYPE $$
$$ \Gamma \vdash t \ccolon T $$
$$ \Gamma \vdash p : T \eqd T' $$
$$ \Gamma \vdash p : t \eqd t' \ccolon T \eqd T' $$

Moreover, when $T$ is $T'$, we may abbreviate
$$ \Gamma \vdash p : t \eqd t' \ccolon T \eqd T' $$
to
$$ \Gamma \vdash p : t \eqd t' \ccolon T $$

Variables introduced by supertypes in the context may have names that are
uninteresting for us, if they aren't referred to again.  To indicate that, we
will write the names of such variables as underscores, as in $\var
\ccolon T_1,\dots,\var \ccolon T_n\Context$.

%% We introduce the supertype notation

%% $$ \Gamma, x \defn t \csynth{T} \Context $$

%% as something semantically the same as

%% $$ \Gamma, x \defn t \ccolon T \Context $$

%% In the inference rules below, we'll indicate directionality of type inference
%% in our algorithms by writing
%% $$\Gamma, x \defn t \csynth{T} \Context$$ to indicate that the type $T$ can
%% be computed from the term $t$ and the rest of the information in $\Gamma$,
%% whereas in $$\Gamma, x \defn t \ccheck{T} \Context$$ the type $T$ is known
%% and the task is to check that $t$ is of type $T$.  In the former case, one says
%% that $t$ synthesizes its type, and in the latter case, that the type of $t$ is
%% to be checked.  Such directional indications are used for ease of thinking
%% about the correctness, description, and implementation of the algorithms.  The
%% algorithms will necessarily be directional, in that some parts of them will be
%% asked to check that an object has a given type, and other parts of which will
%% be asked to manipulate objects whose type has already been determined.

Thanks to Dan Licata and Peter Lumsdaine for suggestions and advice.

\paragraph{Inference rules} 

\begin{enumerate}

\item
\[\inferrule{\ }{\Context}\]

\item

\[\inferrule{\Gamma,x:Q,\Gamma'\Context}{\Gamma,x:Q,\Gamma',y\defn x : Q \Context}\]

\[\inferrule{\Gamma,x \defn p :Q,\Gamma'\Context}{\Gamma,x \defn p :Q,\Gamma',y\defn x : Q \Context}\]

Here (and below) $Q$ represents the tail end of a supertype, not including
the variable or its defined value.  For example, a special case of this rule is the following one.

\[\inferrule{\Gamma,x:T,\Gamma'\Context}{\Gamma,x:T,\Gamma' \vdash x : T}\]

\item
\[\inferrule{\Gamma, x:Q,\Gamma' \Context \\ \Gamma, x \defn t:Q \Context}{\Gamma, x \defn t:Q,\Gamma'\Context}\]

For example, special cases of this rule are the following ones.

\[\inferrule{\Gamma, X \TYPE,\Gamma' \Context \\ \Gamma \vdash T \Type}{\Gamma, X \defn T \TYPE, \Gamma'\Context}\]

\[\inferrule{\Gamma, x:T,\Gamma' \Context \\ \Gamma \vdash t:T}{\Gamma, x \defn t:T,\Gamma'\Context}\]

\item
If the variable $x$ does not appear in $\Gamma'$, then

\[\inferrule{\Gamma,x:Q,\Gamma'\Context}{\Gamma,\Gamma' \Context }\]

and

\[\inferrule{\Gamma, x\defn t:Q,\Gamma'\Context}{\Gamma,\Gamma' \Context }\]

In the latter rule, observe that since we are working modulo unfolding of
definitions, $\Gamma'$ can always be replaced by something that doesn't involve
$x$; that amounts to substituting $t$ for $x$ in $\Gamma'$.

%% \item
%% \[\inferrule{\Gamma,J,J'\Context}{\Gamma,v : J \Rightarrow J' \Context}\]

%% This inference rule introduces a variable $v$ that abstracts the inference of $J'$ from the hypothesis $J$.
%% As mentioned above, we may omit $v$ to indicate that the unused variable introduced by $J'$ is to be recycled, as 
%% in the following equivalent version of the rule.

%% \[\inferrule{\Gamma,J,J'\Context}{\Gamma,J \Rightarrow J' \Context}\]

\item
\[\inferrule{\Gamma\Context}{\Gamma, X \TYPE \Context}\]

This inference rule introduces a type variable $X$.

\item
\[\inferrule{\Gamma\Context}{\Gamma, X \FTYPE \Context}\]

This inference rule introduces a fibrant type variable $X$.

\item
\[\inferrule{\Gamma \vdash T \FTYPE}{\Gamma \vdash T \TYPE}\]

Every fibrant type is a type.

\item
\[\inferrule{\Gamma \vdash T \TYPE}{\Gamma, x \ccolon T \Context}\]

This inference rule introduces a new variable $x$ of type $T$.  This is the
standard way to introduce a proposition $T$ as a hypothesis.  (The hypotheses
active in a context $\Gamma$ are the variables with no defined value.)

The following rule is slightly more powerful; perhaps it is not needed.

\[\inferrule{\Gamma \vdash T \TYPE \\ \Gamma,\Gamma' \Context}{\Gamma, x:T,\Gamma'\Context}\]

Here also, $x$ is new.

\item
\[\inferrule{
  \Gamma \vdash T \TYPE  
  \\
  \Gamma \vdash T' \TYPE }
{\Gamma, w : T \eqd T' \Context}\]

This inference rule introduces a hypothesis asserting equality of $T$ and $T'$ witnessed
by the new variable $w$.

\item
  \[\inferrule{
  \Gamma \vdash p : T \eqd T'
  \\
  \Gamma \vdash t \ccolon T
  \\
  \Gamma \vdash t' \ccolon T'
  } {
  \Gamma, w : t \eqd t' \ccolon T \eqd T' \Context}\]

This inference rule introduces a hypothesis asserting equality of $t$ and $t'$,
witnessed by the new variable $w$.

\item 
\[\inferrule{\Gamma \vdash T \TYPE \\ \Gamma \vdash T' \TYPE \\ T = T'}
       {\Gamma \vdash \ha\Wrefl{}: T\eqd T'}
\]

\item 
\[\inferrule{\Gamma \vdash p:T_1\eqd T_2 }{\Gamma \vdash \ha\Wsymm{p}:T_2\eqd T_1}\]

\item 
\[
  \inferrule{
    \Gamma \vdash p:T_1\eqd T_2
    \\
    \Gamma \vdash q:T_2\eqd T_3
  }
  {\Gamma \vdash \ha\Wtrans{p,q,T_2}: T_1\eqd T_3 }
\]

\item 
\[\inferrule{
  \Gamma \vdash o \ccheck{T}
  \\
  \Gamma \vdash o' \ccheck{T'}
  \\
  T = T'
  \\
  o = o'
  } {
  \Gamma \vdash  \ha\wrefl{}: o \eqd o' \ccolon T \eqd T'
  } 
\]

\item 
\[\inferrule
    {\Gamma \vdash p:o_1\eqd o_2 \ccolon T_1 \eqd T_2}
    {\Gamma \vdash \ha\wsymm{p}:o_2\eqd o_1 \ccolon T_2 \eqd T_1}\]

\item 
\[\inferrule{\Gamma \vdash p:o_1\eqd o_2 \ccolon T_1 \eqd T_2
  \\
  \Gamma \vdash q:o_2\eqd o_3 \ccolon T_2 \eqd T_3
  } {
  \Gamma \vdash \ha\wtrans{p,o_2,T_2,q}:o_1\eqd o_3 \ccolon T_1 \eqd T_3}
\]

\item 
\[\inferrule
    { \Gamma \vdash t \ccolon T \\ \Gamma \vdash p : T \eqd T'}
    { \Gamma \vdash \ha\conv{t,T,p} \ccolon T' }\]

and

\[\inferrule
    { \Gamma \vdash t \ccolon T \\
      \Gamma \vdash p : T \eqd T' }
    { \Gamma \vdash \ha\wconv{} \ccolon t \eqd \ha\conv{t,T,p} \ccolon T \eqd T'}\]

When $T'$ is $T$, it would be nice if $\ha\conv{t,T,\ha\Wrefl{}}$ were equal to
$t$ in a strong sense.

\item

\[\inferrule{\Gamma \vdash n \UNIV  }
       {\Gamma \vdash \Univ_n \FTYPE  }\]

\[\inferrule{\Gamma \vdash n \UNIV  }
       {\Gamma \vdash \FUniv_n \FTYPE  }\]

\item

\[\inferrule{
  \Gamma \vdash o \csynth{\Univ_n}}{
  \Gamma \vdash \ha\El{n,o}\TYPE }\]

\[\inferrule{
  \Gamma \vdash o \csynth{\FUniv_n}}{
  \Gamma \vdash \ha\ElF{n,o}\FTYPE }\]

\item 

\[\inferrule{\Gamma \vdash p : o \eqd o' \ccheck \Univ_n}
       {\Gamma \vdash \ha\weleq{p} : \ha\El{n,o} \eqd \ha\El{n,o'}}\]

\[\inferrule{\Gamma \vdash p : o \eqd o' \ccheck \FUniv_n}
       {\Gamma \vdash \ha\weleq{p} : \ha\ElF{n,o} \eqd \ha\ElF{n,o'}}\]

\item
\[\inferrule{
  \Gamma \vdash o \csynth{\FUniv_n}
}{
  \Gamma \vdash \ha\univinc{o} \csynth{\Univ_n}
}\]

\item
\[\inferrule{
  \Gamma \vdash o \csynth{\FUniv_n}
}{
  \Gamma \vdash \ha\welfeq{} : \ha\ElF{n,o} \eqd \ha\El{n,\ha\univinc{o}}
}\]


%% \item
%% The following rules, concerning $\Type$, the type of all small types, are
%% experimental.  A {\em small} type is one of the form $\ha\El{n,t}$, for some
%% $n$ and some $t$.

%% \begin{mathparpagebreakable}
%% \inferrule{\ }
%%        {\Gamma \vdash \Type \TYPE }
%% \and
%% \inferrule{\Gamma \vdash T \ccolon \Type}
%%        {\Gamma \vdash T \TYPE}
%% \and
%% \inferrule{\Gamma \vdash t \ccolon \Univ_n}
%%        {\Gamma \vdash \ha\El{n,t} \ccheck \Type}
%% \and
%% \inferrule{\Gamma \vdash p : t \eqd t' \ccheck \Univ_n}
%%        {\Gamma \vdash \ha\weleq{p} : \ha\El{n,t} \eqd \ha\El{n,t'} : \Type }
%% \end{mathparpagebreakable}

\item 
\[\inferrule{ \Gamma, \var \ccolon T \vdash U\TYPE  }{\Gamma \vdash \ha\tprod{T,.U}\TYPE}\]

Here $.U$ is notation for abstraction: binding an anonymous variable to the
expression $U$; we will also use the notation $x.U$ when binding a named
variable $x$, as in the following equivalent version of the same rule.

\[\inferrule{ \Gamma, x \ccolon T \vdash U\TYPE  }
       {\Gamma \vdash \ha\tprod{T,x.U}\TYPE}\]

\item 
\[\inferrule{
  \Gamma \vdash T \FTYPE \\
  \Gamma, \var \ccolon T \vdash U \FTYPE  
}{
  \Gamma \vdash \ha\tprod{T,.U} \FTYPE
}\]

\item 
\[\inferrule{
  \Gamma, \var \ccolon T \vdash u \ccheck{U}
}{\Gamma \vdash \ha\lambda{.u} \ccheck{\ha\tprod{T,.U}}}
\]

\item 
\[ \inferrule{ 
  \Gamma \vdash p:T \eqd T'  \\
  \Gamma, x \ccolon T \vdash U \TYPE \\
  \Gamma, x' \ccolon T' \vdash U' \TYPE \\
  \Gamma, x \ccolon T, x' \ccolon T', w : x \eqd x' \ccolon T \eqd T' \vdash q : U[x] \eqd U'[x'] 
  } {
  \Gamma \vdash \ha\wpieq{p,...q}:\ha\tprod{T,x.U}\eqd \ha\tprod{T',x'.U'}
}\]

\item 
\[ \inferrule{ 
  \Gamma \vdash p:T \eqd T' \\
  \Gamma, x \ccolon T \vdash u : U \\
  \Gamma, x' \ccolon T' \vdash u' : U' \\
  \Gamma, x \ccolon T, x' \ccolon T', w : x \eqd x' \ccolon T \eqd T' \vdash q : u[x] \eqd u'[x'] : U[x] \eqd U'[x'] 
  } {
  \Gamma \vdash \ha\wlambda{p,...q} : \ha\lambda{.u}\eqd \ha\lambda{.u'} : \ha\tprod{T,.U} \eqd \ha\tprod{T',.U'}
}\]

\item 
\[\inferrule{
  \Gamma \vdash f \ccheck{\ha\tprod{T,.U}}
  \\ 
  \Gamma \vdash t \ccheck{T}
  \\
  U' = U[\haa t T] 
}{
  \Gamma \vdash \ha \ev{f,t,{\ha\tprod{T,.U}}} \csynth U'
}\]

%% The annotation is present to ensure that the sentence $$\Gamma, \var \defn
%% U[\haa t T] \TYPE \Context$$ is checkable.

Question: what makes the sentence 
\[ \Gamma \vdash U[\haa t T] \TYPE \]
checkable, in the context above?

The rule above can be expressed without using substitution, as follows.
\[\inferrule{
  \Gamma \vdash f \ccheck{\ha\tprod{T,x.U}}
  \\ 
  \Gamma \vdash t \ccheck{T}
}{
  \Gamma, x \defn t : T \vdash \ha \ev{f,t,{\ha\tprod{T,x.U}}} \csynth U
}\]
The disadvantages are that the conclusion has something other than $\Gamma$ to the
left of the turnstile, and the name of the variable becomes important.

\item 
\[\inferrule{
   \Gamma \vdash p : f \eqd f' \ccolon {\ha\tprod{T,.U}} \eqd {\ha\tprod{T',.U'}} 
   \\ 
   \Gamma \vdash q : t \eqd t' \ccolon T \eqd T'
   }{
   \Gamma \vdash \ha\weveq{p,q} : \ha\ev{f,t,{\ha\tprod{T,.U}}} \eqd \ha\ev{f',t',{\ha\tprod{T',.U'}}} \ccolon U[\haa t T] \eqd U'[\haa {t'} {T'}]
  }\]

\item 
% beta
\[\inferrule{
  \Gamma \vdash \ha\lambda{.u} \ccheck {\ha\tprod{T,.U}}
  \\
  \Gamma \vdash t \ccheck{T} 
  }{
  \Gamma \vdash \ha\wbeta{} : \ha\ev{\ha\lambda{.u},t,{\ha\tprod{T,.U}}} \eqd u[\haa{t}{T}] : U[\haa{t}{T}]
}\]

%% Replacing $\ha\lambda{.u}$ by $\haa{\ha\lambda{.u}}{\ha\tprod{T,.U}}$ would
%% be an alternative to putting $T$ and $.U$ in the witness.  Comparison of two
%% terms of the same type by normalization need not involve computation of the
%% types of partially applied results, so a version of this rule free of type
%% annotations is needed.

%% (It would be better if $\beta$-reduction were free-running, without the
%% necessity of tracking the types $T$ and $U$.)

% eta
\item 
\[
  \inferrule{\Gamma \vdash f \ccheck{\ha\tprod{T,.U}}}
       {\Gamma \vdash \ha\weta{} : f \eqd \ha\lambda{t.\ha\ev{f,t,{\ha\tprod{T,.U}}}} : \ha\tprod{T,.U}
       }
\]

\item
\[
\inferrule{\Gamma \Context}
     {\Gamma \vdash \NN \TYPE }
\]

\item
\[
\inferrule{\Gamma \Context}
     {\Gamma \vdash \zeroN \ccheck \NN }
\]

\item
\[
\inferrule{ \Gamma \vdash n \ccheck \NN }
     {\Gamma \vdash \ha \succN {n} \ccheck \NN }
\]

\item

This rule and the following three deal with defining a family of types by
induction on $\NN$.  
%% If we treat types as objects of a type called $\Type$,
%% they won't be necessary.

\[
\inferrule{
  \Gamma \vdash B \TYPE
  \\
  \Gamma, n \ccheck \NN, C \TYPE \vdash D \TYPE
  \\
  \Gamma \vdash n \ccheck \NN
}
     {\Gamma \vdash \ha\indtN{B,..D,n} \TYPE }
\]

\item
\[
\inferrule{
  \Gamma \vdash B \TYPE
  \\
  \Gamma, n \ccheck \NN, C \TYPE \vdash D \TYPE
}
     {\Gamma \vdash \ha\windo{} : \ha\indtN{B,..D,\zeroN} \eqd B }
\]

\item
\[
\inferrule{
  \Gamma \vdash B \TYPE
  \\
  \Gamma, n \ccheck \NN, C \TYPE \vdash D \TYPE
  \\
  \Gamma \vdash n \ccheck \NN
}
     {\Gamma \vdash \ha\winds{} : \ha\indtN{B,..D,\succN[n]} \eqd D[n,\ha\indtN{B,..D,n}] }
\]

\item
\[
\inferrule{
  \Gamma \vdash q : B \eqd B'
  \\
  \Gamma, n \ccheck \NN, C \TYPE \vdash D \TYPE
  \\
  \Gamma, n \ccheck \NN, C' \TYPE \vdash D' \TYPE
  \\
  \Gamma, n \ccheck \NN, \var : C \eqd C' \vdash r : D[n,C] \eqd D'[n,C']
  \\
  \Gamma \vdash s : n \eqd n' \ccheck \NN
}
     {\Gamma \vdash \ha\windeq{q,..r,s} : \ha\indtN{B,..D,n} \eqd \ha\indtN{B',..D',n'} }
\]

\item
\[
\inferrule{
  \Gamma \vdash b \ccheck T[\zeroN]
  \\
  \Gamma, n \ccheck \NN, c \ccheck T \vdash d \ccheck T[\succN[n]]
  \\
  \Gamma \vdash n \ccheck \NN
}
     {\Gamma \vdash \ha\indN{.T,b,..d,n} : T[n] }
\]

\item
\[
\inferrule{
  \Gamma \vdash b \ccheck T[\zeroN]
  \\
  \Gamma, n \ccheck \NN, c \ccheck T \vdash d \ccheck T[\succN[n]]
}
     {\Gamma \vdash \ha\windo{} : \ha\indN{.T,b,..d,\zeroN} \eqd b : T[\zeroN] }
\]

\item
\[
\inferrule{
  \Gamma \vdash b \ccheck T[\zeroN]
  \\
  \Gamma, n \ccheck \NN, c \ccheck T \vdash d \ccheck T[\succN[n]]
  \\
  \Gamma \vdash n \ccheck \NN
}
     {\Gamma \vdash \ha\winds{} : \ha\indN{.T,b,..d,\succN[n]} \eqd d[n,\ha\indN{.T,b,..d,n}] : T[\succN[n]] }
\]

\item
\[
\inferrule{
  \Gamma, n \ccheck \NN \vdash p : T \eqd T'
  \\
  \Gamma \vdash q : b \eqd b' \ccheck T[\zeroN] \eqd T'[\zeroN]
  \\
  \Gamma, n \ccheck \NN, c \ccheck T[n] \vdash d \ccheck T[\succN[n]]
  \\
  \Gamma, n \ccheck \NN, c' \ccheck T'[n] \vdash d' \ccheck T'[\succN[n]]
  \\
  \Gamma, n \ccheck \NN, \var : c \eqd c' \ccheck T[n] \eqd T'[n] \vdash r : d[n,c] \eqd d'[n,c'] \ccheck T[\succN[n]] \eqd T'[\succN[n]]
  \\
  \Gamma \vdash s : n \eqd n' \ccheck \NN
}
     {\Gamma \vdash \ha\windeq{.p,q,..r,s} : \ha\indN{.T,b,..d,n} \eqd \ha\indN{.T',b',..d',n'} : T[n] \eqd T'[n'] }
\]

\item
\[
  \inferrule {
    \Gamma \vdash p : T[\zeroN] \eqd T'[\zeroN]
    \\
    \Gamma, n \ccheck \NN, \var : T \eqd T' \vdash q : T[\succN[n]] \eqd T'[\succN[n]]
    \\
    \Gamma \vdash n \ccheck \NN
  } {
    \Gamma \vdash \ha\wetatN{.T,.T',p,..q,n} : T[n] \eqd T'[n]
  }
\]

\item
\[
  \inferrule {
    \Gamma, n \ccheck \NN \vdash t : T
    \\
    \Gamma, n \ccheck \NN \vdash t' : T'
    \\
    \Gamma \vdash p : t[\zeroN] \eqd t'[\zeroN] : T[\zeroN] \eqd T'[\zeroN]
    \\
    \Gamma, n \ccheck \NN, \var : t[n] \eqd t'[n] : T[n] \eqd T'[n] \vdash q : t[\succN[n]] \eqd t'[\succN[n]] : T[\succN[n]] \eqd T'[\succN[n]]
    \\
    \Gamma \vdash n \ccheck \NN
  } {
    \Gamma \vdash \ha\wetaN{.T,.T',.t,.t',p,..q,n} : t[n] \eqd t'[n] : T[n] \eqd T'[n]
  }
\]

\item
The following rules are included, because they correspond to meta-theorems that
we intend should hold; they are not expected to be useful in constructing
proofs, and they shouldn't participate in derivations considered by the
uniqueness statement of the introduction.

\begin{mathparpagebreakable}
  \inferrule{\Gamma \vdash t \ccolon T}
       {\Gamma, \var \ccolon T \Context}
  \and
  \inferrule{\Gamma, \var \ccolon T \Context}
       {\Gamma \vdash T \TYPE}
  \and
  \inferrule{\Gamma \vdash p \ccolon T \eqd T'}
       {\Gamma, \var \ccolon T \eqd T' \Context}
  \and
  \inferrule{\Gamma, \var \ccolon T \eqd T' \Context}
       {\Gamma \vdash T \TYPE}
  \and
  \inferrule{\Gamma, \var \ccolon T \eqd T' \Context}
       {\Gamma \vdash T' \TYPE}
  \and
  \inferrule{\Gamma \vdash p : t \eqd t' \ccolon T \eqd T'}
       {\Gamma, \var : t \eqd t' \ccolon T \eqd T' \Context}
  \and
  \inferrule{\Gamma, \var : t \eqd t' \ccolon T \eqd T' \Context}
       {\Gamma \vdash t \ccolon T}
  \and
  \inferrule{\Gamma, \var : t \eqd t' \ccolon T \eqd T' \Context}
       {\Gamma \vdash t' \ccolon T'}

\end{mathparpagebreakable}

\item
It should be a meta-theorem that if
\[{\Gamma \vdash p : t \eqd t' \ccolon T \eqd T'}\]
is derivable, then, for some $p'$,
\[{\Gamma \vdash p' : T \eqd T'}\]
is derivable.  Alternatively, it might be a good idea to keep track of the
witness $p'$ by writing something like
\[{\Gamma, \var \defn p : t \eqd t' \ccolon p' : T \eqd T' \Context}\]
or
\[{\Gamma, \var : t \eqd t' \ccolon p' : T \eqd T' \Context}\]

\end{enumerate}

\bibliography{alggeom}
\bibliographystyle{plain}
\end{document}
  %% Local Variables:
  %% compile-command: "pdflatex TTS-internal-witnesses.tex "
  %% End:

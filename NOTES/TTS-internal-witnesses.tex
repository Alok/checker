\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amscd, amssymb}
\usepackage{enumerate}
\usepackage{mathtools}          %to get \vcentcolon

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parindent = 0.0in

\renewcommand{\thesubsection}{\arabic{subsection}}

\newenvironment{eq}{\begin{equation}}{\end{equation}}

\newenvironment{proof}{{\bf Proof}:}{\vskip 5mm }
\newenvironment{rem}{{\bf Remark}:}{\vskip 5mm }
\newenvironment{remarks}{{\bf Remarks}:\begin{enumerate}}{\end{enumerate}}
\newenvironment{examples}{{\bf Examples}:\begin{enumerate}}{\end{enumerate}}  

\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{definition}[proposition]{Definition}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{cor}[proposition]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{pretheorem}[proposition]{Pretheorem}
\newtheorem{hypothesis}[proposition]{Hypothesis}
\newtheorem{example}[proposition]{Example}
\newtheorem{remark}[proposition]{Remark}
\newtheorem{ex}[proposition]{Exercise}
\newtheorem{cond}[proposition]{Conditions}
\newtheorem{cons}[proposition]{Construction}

%\newcommand{\C}[4]{\left[\begin{array}{rcl}&#1\\#3&\dw\dw&#4\\&#2\end{array}\right]}
\newcommand{\llabel}[1]{\label{#1}[{\bf #1}]}
%\newcommand{\llabel}[1]{\label{#1}}
\newcommand{\comment}[1]{}
\newcommand{\sr}{\rightarrow}
\newcommand{\lr}{\longrightarrow}
\newcommand{\xr}{\xrightarrow}
\newcommand{\dw}{\downarrow}
\newcommand{\bdl}{\bar{\Delta}}
\newcommand{\zz}{{\bf Z\rm}}
\newcommand{\zq}{{\bf Z}_{qfh}}
\newcommand{\nn}{{\bf N\rm}}
\newcommand{\qq}{{\bf Q\rm}}
\newcommand{\nq}{{\bf N}_{qfh}}
\newcommand{\oo}{\otimes}
\newcommand{\uu}{\underline}
\newcommand{\ih}{\uu{Hom}}
\newcommand{\af}{{\bf A}^1}
\newcommand{\wt}{\widetilde}
\newcommand{\gm}{{\bf G}_m}
\newcommand{\dsr}{\stackrel{\sr}{\scriptstyle\sr}}
%\newcommand{\PP}{$P_{\infty}$}
\newcommand{\tp}{\tilde{D}}
\newcommand{\HH}{$H_{\infty}$}
\newcommand{\ii}{\stackrel{\scriptstyle\sim}{\sr}}
\newcommand{\BB}{_{\bullet}}
\newcommand{\D}{\Delta}
\newcommand{\colim}{{\rm co}\hspace{-1mm}\lim}
\newcommand{\cf}{{\it cf} }
\newcommand{\msf}{\mathsf }
\newcommand{\mcal}{\mathcal }
\newcommand{\ep}{\epsilon}
\newcommand{\tl}{\widetilde}
\newcommand{\ub}{\mbox{\rotatebox{90}{$\in$}}}
\newcommand{\ssp}{\,\,\,\,\,\,\,\,}
\newcommand{\red}{\twoheadrightarrow}
\newcommand{\eqg}{\stackrel{\Gamma}{\approx}}
\newcommand{\alphaeq}{\stackrel{\alpha}{\sim}}
\newcommand{\rtr}{\triangleright}

\newcommand{\piece}{\vskip 3mm\noindent\refstepcounter{proposition}{\bf
\theproposition}\hspace{2mm}}
\newcommand{\subpiece}{\vskip 3mm\noindent\refstepcounter{equation}{\bf\theequation}
\hspace{2mm}}{\vskip
3mm}

\newcommand{\TT}{{\bf Type0}}
\newcommand{\PP}{{\bf Prop}}
\newcommand{\cc}{{\bf c}}
\newcommand{\rect}{{\bf rect}}
\newcommand{\eqd}{\equiv}

\newcommand{\cu}{{u}}
\newcommand{\Eu}{{\cal U}}
\newcommand{\JJ}[2]{{J(#1,#2)\,}}
\newcommand{\J}[1]{{J(#1)\,}}
\newcommand{\jj}[3]{{j(#1,#2,#3)\,}}
\newcommand{\jr}[2]{{jr(#1, #2)\,}}
\newcommand{\jl}[2]{{jl(#1, #2)\,}}
\newcommand{\UU}[1]{{UU(#1)}}
\newcommand{\rd}{\succ}
\newcommand{\rde}{\succeq}
\newcommand{\rdA}{\rd_{\AA}}
\newcommand{\brd}{\equiv}
\newcommand{\ind}{Ind\,\,}
\newcommand{\erd}[1]{\equiv_{{\AA},#1}}
\newcommand{\spc}{{\,\,\,\,\,\,\,}}
\renewcommand{\AA}{{\cal A}}

\newcommand{\ccolon}{\vcentcolon}
\newcommand{\ccheck}{\vcentcolon}            % was \Leftarrow
\newcommand{\csynth}{\vcentcolon\vcentcolon} % was \Rightarrow
\renewcommand{\csynth}{\ccheck}              % was \Rightarrow

\newcommand{\Univ}{\mathop{\text{ \sc univ}}}
\newcommand{\Type}{\mathop{\text{ \sc type}}}
\newcommand{\Okay}{\mathop{\text{ \sc okay}}}
\newcommand{\Context}{\vdash\Okay}
\renewcommand{\Context}{\vdash}
\newcommand{\ha}[2]{#1[#2]}
\newcommand{\Wrefl}{{\sf Wrefl}}
\newcommand{\weta}{{\sf weta}}
\newcommand{\Wtrans}{{\sf Wtrans}}
\newcommand{\Wsymm}{{\sf Wsymm}}
\newcommand{\El}{{\sf El}}
\newcommand{\annot}{{\sf annot}}
\newcommand{\haa}[2]{\ha\annot{#1,#2}}
\renewcommand{\haa}[2]{#1}
\newcommand{\conv}{{\sf conv}}
\newcommand{\wconv}{{\sf wconv}}
\newcommand{\ev}{{\sf ev}}
\newcommand{\wbeta}{{\sf wbeta}}
\newcommand{\weleq}{{\sf weleq}}
\newcommand{\weveq}{{\sf weveq}}
\newcommand{\wl}{{\sf wl}}
\newcommand{\wpi}{{\sf wpi}}
\newcommand{\wrefl}{{\sf wrefl}}
\newcommand{\wsymm}{{\sf wsymm}}
\newcommand{\wtrans}{{\sf wtrans}}
\newcommand{\var}{\char`_}
\newcommand{\defn}{\vcentcolon\equiv}

\begin{document}

\parskip = 2mm
\begin{center}
{\bf\Large A test type system}

{\bf Vladimir Voevodsky}

{Started January 25, 2013}  

{This version modified by Dan Grayson}  
\end{center}

\tableofcontents

This note gives some ideas about the test type system TTS with secondary
witnessed which Dan Grayson and I have been working on implementing. While TTS
by itself has (most likely) decidable definitional equality and typing making
secondary witnesses to be formally speaking unnecessary, they become essential
for the implementation of more complex systems with undecidable typing such as
HTS.

We are aiming at a type system where every derivable extended sentence can be
obtained by a unique inference rules such that one gets a bijection between
inference trees and $\alpha$-equivalence classes of derivable extended
sentences.  The extension is chosen here in a minimal way.

\subsection{Rules}

A {\em supertype} $J$ has one of the following forms:

$$ u \Univ $$
$$ u \defn n \Univ $$
$$ X \Type $$
$$ X \defn T \Type $$
$$ x \ccolon T $$
$$ x \defn t \ccolon T $$
$$ w : T \eqd T' $$
$$ w \defn p : T \eqd T' $$
$$ w : t \eqd t' \ccolon T \eqd T' $$
$$ w \defn p : t \eqd t' \ccolon T \eqd T' $$
$$ J \Rightarrow J' $$

where $U$, $X$, $x$, or $w$ is the (single) variable {\em introduced} by the
supertype, where $n$, $p$, $t$, $t'$, $T$, $T'$ are expressions, possibly with
free variables, that define values for the variables (as indicated by the
operator $\defn$), and where $J$ and $J'$ are supertypes.  The variable
introduced by $J$ is regarded as bound in $J'$, and the variable introduced by
$J'$ is co-opted to serve as the variable introduced by $ J \Rightarrow J' $.

A {\em context} or {\em sentence} $\Gamma$ is a list of supertypes, each of
which has all of its free variables bound by variables introduced earlier in
the list.  Alternatively, we may say the variable introduced by a supertype in
the list is bound in the remainder of the list.

The witnesses $w$ and $p$ are the additional data that makes these sentences
{\em extended}, and need be recorded only if the derivation tree needs to
recoverable from the derived sentence.

Inference rules given later determine which sentences are well-formed and
derivable.

The notation $$\Gamma \Context$$ will be used to indicate that $\Gamma$ is
well-formed.

Variables introduced by supertypes in the context may have names that are
uninteresting for us, if they aren't referred to again.  To indicate that, we
will write the names of such variables as underscores, as in $\var
\ccolon T_1,\dots,\var \ccolon T_n\Context$.

%% We introduce the supertype notation

%% $$ \Gamma, x \defn t \csynth{T} \Context $$

%% as something semantically the same as

%% $$ \Gamma, x \defn t \ccolon T \Context $$

%% In the inference rules below, we'll indicate directionality of type inference
%% in our algorithms by writing
%% $$\Gamma, x \defn t \csynth{T} \Context$$ to indicate that the type $T$ can
%% be computed from the term $t$ and the rest of the information in $\Gamma$,
%% whereas in $$\Gamma, x \defn t \ccheck{T} \Context$$ the type $T$ is known
%% and the task is to check that $t$ is of type $T$.  In the former case, one says
%% that $t$ synthesizes its type, and in the latter case, that the type of $t$ is
%% to be checked.  Such directional indications are used for ease of thinking
%% about the correctness, description, and implementation of the algorithms.  The
%% algorithms will necessarily be directional, in that some parts of them will be
%% asked to check that an object has a given type, and other parts of which will
%% be asked to manipulate objects whose type has already been determined.

We intend the inference rules to satisfy some meta-theorems.  For example, if 
$$ \Gamma, \var \defn t \ccolon T \Context $$
is derivable, then
$$ \Gamma, \var \defn T \Type \Context $$
should be derivable, too.  If
$$ \Gamma, \var \defn p \ccolon T \eqd T' \Context $$
is derivable, then
$$ \Gamma, \var \defn T \Type \Context $$
and
$$ \Gamma, \var \defn T' \Type \Context $$
should be derivable, too.  Finally, if 
$$ \Gamma, \var \defn p : t \eqd t' \ccolon T \eqd T' \Context $$
is derivable, then
$$ \Gamma, \var \defn t \ccolon T \Context $$
and
$$ \Gamma, \var \defn t' \ccolon T' \Context $$
should be derivable, too.

Thanks to Dan Licata and Peter Lumsdaine for suggestions and advice.

\paragraph{Inference rules} 

\begin{enumerate}

\item
$$\frac{}{\Context}$$

\item
$$\frac{\Gamma,J,J'\Context}{\Gamma,J \Rightarrow J' \Context}$$

\item
$$\frac{\Gamma\Context}{\Gamma, X \Type \Context}$$

This item introduces a variable $X$ representing a type.

\item
$$\frac{\Gamma, X \defn T \Type \Context}{\Gamma, x \ccolon T \Context}$$

This item introduces a variable $x$ of type $T$.  This is intended to be the
standard way to introduce a proposition $T$ as a hypothesis.  (The hypotheses
active in a context $\Gamma$ are the variables with no defined value.)

\item
$$\frac{
  \Gamma, X \defn T \Type\Context  
  \spc
  \Gamma, X' \defn T' \Type\Context }
{\Gamma, w : T \eqd T' \Context}$$

This item introduces a hypothesis asserting equality of $T$ and $T'$ witnessed
by the new variable $w$.

\item
  \[\frac{
  \Gamma, \var \defn t \ccolon T \Context
  \spc
  \Gamma, \var \defn t' \ccolon T' \Context
  } {
  \Gamma, w : t \eqd t' \ccolon T \eqd T' \Context}\]

\item 
\[\frac{\Gamma, \var \defn T \Type \Context \spc \Gamma, \var \defn T'\Type \Context
  \spc T\sim T'}{
  \Gamma, \var \defn \ha\Wrefl{}: T\eqd T' \Context
}
\]

Here $T\sim T'$ denotes a comparison operation on terms, which treats certain
operations specially, as mentioned below.

\item 
$$\frac{\Gamma,\var\defn p:T_1\eqd T_2 \Context }{\Gamma, \var\defn \ha\Wsymm{p}:T_2\eqd T_1 \Context}$$

\item 
\[
  \frac{
    \Gamma, \var \defn p:T_1\eqd T_2 \Context
    \spc
    \Gamma, \var \defn q:T_2\eqd T_3 \Context
  }
  {\Gamma, \var \defn \ha\Wtrans{p,q,T_2}: T_1\eqd T_3 \Context}
\]

\item 
\[\frac{
  \Gamma, \var \defn o \ccheck{T} \Context
  \spc
  \Gamma, \var \defn o' \ccheck{T} \Context
  \spc
  o \sim o'
  } {
  \Gamma, \var \defn  \ha\wrefl{}: o \eqd o' \ccolon T \eqd T \Context
  } 
\]

\item 
\[\frac
    {\Gamma, \var \defn p:o_1\eqd o_2 \ccolon T_1 \eqd T_2 \Context}
    {\Gamma, \var \defn \ha\wsymm{p}:o_2\eqd o_1 \ccolon T_2 \eqd T_1 \Context}\]

\item 
\[\frac{\Gamma \var\defn p:o_1\eqd o_2 \ccolon T_1 \eqd T_2 \Context 
  \spc
  \Gamma, \var\defn q:o_2\eqd o_3 \ccolon T_2 \eqd T_3 \Context
  } {
  \Gamma, \var \defn \ha\wtrans{p,o_2,T_2,q}:o_1\eqd o_3 \ccolon T_1 \eqd T_3 \Context}
\]

\item 
\[\frac
    { \Gamma, \var \defn o \ccolon T \Context \spc \Gamma, \var \defn p : T \eqd T' \Context }
    { \Gamma, \var \defn \ha\conv{o,T,p} \ccolon T' \Context}\]

and

\[\frac
    { \Gamma, \var \defn o \ccolon T \Context \spc \Gamma, \var \defn p : T \eqd T' \Context }
    { \Gamma, \var \defn \ha\wconv{} \ccolon o \eqd \ha\conv{o,T,p} \ccolon T \eqd T' \Context}\]

%%% probably obsolete:
%% In any comparisons $T\sim T'$ and $o\sim o'$, a term of the form
%% $\ha\conv{o,T'',p}$ is regarded as equivalent to $o$.

%% \item 
%% \[\frac{\Gamma, \var\defn o \ccheck{T} \Context}{\Gamma, \var\defn \haa o T \csynth{T}\Context}\]

%% In any comparisons $T\sim T'$ and $o\sim o'$, a term of the form
%% $\haa o T$ is regarded as equivalent to $o$.

\end{enumerate}

\paragraph{Universes}

\begin{enumerate}

\item

\[\frac{\Gamma, \var \defn n \Univ \Context }{\Gamma, \var \defn \Eu_n \Type \Context }\]

\item

\[\frac{
  \Gamma, \var \defn n \Univ \Context 
  \spc
  \Gamma, \var \defn o \csynth{\Eu_n} \Context}{
  \Gamma, \var \defn \ha\El{n,o}\Type \Context }\]

\item 

\[\frac{
  \Gamma, \var \defn n \Univ \Context
  \spc
  \Gamma, \var \defn p : o \eqd o' \ccheck{\Eu_n} \Context
}
       {\Gamma, \var \defn \ha\weleq{n,p} : \ha\El{n,o} \eqd \ha\El{n,o'} \Context}\]

\end{enumerate}

\paragraph{Dependent products}

\begin{enumerate}

\item 
\[\frac{ \Gamma, \var \ccolon T, \var \defn U\Type \Context }{\Gamma, \var \defn \ha\prod{T,.U}\Type\Context}\]

Here $.U$ is notation for abstraction: binding an anonymous variable to the
expression $U$; we will also use the notation $x.U$ when binding a named
variable $x$, as in the following version of the same rule.

\[\frac{ \Gamma, x \ccolon T, \var \defn U\Type \Context }{\Gamma, \var \defn
  \ha\prod{T,x.U}\Type \Context}\]

\item 
\[ \frac{ 
  \Gamma, x' \ccolon T', \var \defn U'  \Type \Context \spc 
  \Gamma, \var \defn p:T \eqd T' \Context \spc
  \Gamma,  x \ccolon T, \var \defn q:U \eqd p^*U' \spc
  } {
  \Gamma, \var \defn \ha\wpi{p,x.q}:\ha\prod{T,x.U}\eqd \ha\prod{T',x'.U'} \Context
}\]

Here ${p}^*U'$ is notation for $U'[\haa {\ha\conv{x,T,p}} {T'}/x]$, where
$U'[e/x]$ is notation for replacing the variable $x$ in $U'$ by the expression
$e$.

In the presence of $$\Gamma, \var \defn p:T \eqd T' \Context $$ it should be a
meta-theorem that $$\Gamma, x' \ccolon T', \var \defn U' \Type \Context$$ is
derivable if and only if $$\Gamma, x \ccolon T, \var \defn p^* U' \Type
\Context$$ is derivable.

\item 
\[\frac{
  \Gamma, \var \ccolon T, \var\defn o \ccheck{U} \Context
}{\Gamma, \var\defn \ha\lambda{.o} \ccheck{\ha\prod{T,.U}} \Context}
\]

%% Some space is saved by not annotating $\ha\lambda{.o}$ internally with $T$ and
%% $.U$; an external annotation of the form $\haa {\ha\lambda{.o}} {\ha\prod{T,.U}} $ may be used instead.

\item 
\[\frac{
  \Gamma, \var \ccolon T, \var\defn p : o\eqd o' \ccheck{U} \Context
}{
  \Gamma, \var\defn \ha\wl{.p} : \ha\lambda{.o}\eqd \ha\lambda{.o'} : \ha\prod{T,.U} \Context
}\]

FIX THIS.

\item 
\[\frac{
  \Gamma, \var\defn f \ccheck{\ha\prod{T,.U}} \Context
  \spc 
  \Gamma, \var\defn t \ccheck{T}\Context
  \spc
  U' = U[\haa t T]
}{
  \Gamma, \var\defn \ha \ev{f,t,T,.U} \csynth{U'} \Context
}\]

Here $U[o]$ is notation for replacing the first variable of $U$ by $o$, with
the second variable of $U$ becoming the first, and so on.  

The relation $U' = U[\haa t T]$ between type expressions indicates equality up to
renaming of local variables and expansion of definitions.

%% The annotation is present to ensure that the sentence $$\Gamma, \var \defn
%% U[\haa t T] \Type \Context$$ is checkable.

Question: what makes the sentence $$\Gamma, \var \defn U[\haa t T] \Type
\Context$$ checkable?

\item 
\[\frac{
   \Gamma, \var\defn p : f \eqd f' \ccolon{\ha\prod{T,.U}} \Context
   \spc 
   \Gamma, \var\defn q : t \eqd t' \ccolon T \Context
   }{
   \Gamma, \var\defn \ha\weveq{p,q} : \ha\ev{f,t,T,.U} \eqd \ha\ev{f',t',T,.U}
   \ccolon U[\haa t T] \eqd U[\haa {t'} T] \Context
  }\]

FIX THIS.

Question: what term $q'$ will make the following sentence derivable?
$$ \Gamma, \var \defn q' : U[\haa t T] \eqd U[\haa {t'} T] \Type \Context $$
How does the rule above relate to $q'$?

\item 
\[\frac{
  \Gamma, \var\defn f \ccheck{\ha\prod{T,.U}} \Context
  \spc
  \Gamma, \var\defn p \ccolon t \eqd t' \ccolon T \eqd T'
}{
  \Gamma, \var\defn ... : \ha\ev{f,t,T,.U} \eqd \ha\ev{f,t',T',.U} \ccolon U[\haa t T] \eqd U[\haa {t'} T] \Context
}\]

\dots incomplete \dots

Question: what makes $$\Gamma, \var\defn ... : \ha\ev{f,\ha\conv{t,T,p},T',.U}
\ccolon U[\haa t T] \Context$$ checkable?

\item 
\[\frac{
  \Gamma, \var\defn f \ccheck{\ha\prod{T,.U}} \Context
  \spc 
  \Gamma, \var\defn t \ccheck{T}\Context
  \spc
  \Gamma, \var\defn T, \var\defn q \ccolon U \eqd U'
}{
  \Gamma, \var\defn ... : \ha\ev{f,t,T,.U} \eqd \ha\ev{f,t,T,.U'}
   \ccolon U[\haa t T] \Context
}\]

\dots incomplete \dots

Question: what makes $$ \Gamma, \var\defn ... : \ha\ev{f,t,T,.U'}
\ccolon U[\haa t T] \Context $$ checkable?

\item 
% beta
\[\frac{
  \Gamma, \var\defn t \ccheck{T} \Context
  \spc
  \Gamma, \var \ccolon T, \var\defn u \ccheck{U} \Context
  }{
  \Gamma,\var\defn \ha\wbeta{} : \ha\ev{\ha\lambda{.u},t,T,.U} \eqd
  u[\haa{t}{T}] : U[\haa{t}{T}] \Context
}\]

%% Replacing $\ha\lambda{.u}$ by $\haa{\ha\lambda{.u}}{\ha\prod{T,.U}}$ would
%% be an alternative to putting $T$ and $.U$ in the witness.  Comparison of two
%% terms of the same type by normalization need not involve computation of the
%% types of partially applied results, so a version of this rule free of type
%% annotations is needed.

(It would be better if $\beta$-reduction were free-running, without the
necessity of tracking the types $T$ and $U$.)

% eta
\item 
\[
  \frac{\Gamma, \var\defn f \ccheck{\ha\prod{T,.U}}\Context}
       {\Gamma, \var\defn \ha\weta{} : f \eqd \ha\lambda{t.\ha\ev{f,t,T,.U}} : \ha\prod{T,.U}\Context}
\]

\end{enumerate}

\bibliography{alggeom}
\bibliographystyle{plain}
\end{document}
  %% Local Variables:
  %% compile-command: "pdflatex TTS-internal-witnesses.tex "
  %% End:

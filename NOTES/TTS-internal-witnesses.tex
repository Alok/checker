\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amscd, amssymb}
\usepackage{enumerate}
\usepackage{mathtools}          %to get \vcentcolon

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parindent = 0.0in

\renewcommand{\thesubsection}{\arabic{subsection}}

\newenvironment{eq}{\begin{equation}}{\end{equation}}

\newenvironment{proof}{{\bf Proof}:}{\vskip 5mm }
\newenvironment{rem}{{\bf Remark}:}{\vskip 5mm }
\newenvironment{remarks}{{\bf Remarks}:\begin{enumerate}}{\end{enumerate}}
\newenvironment{examples}{{\bf Examples}:\begin{enumerate}}{\end{enumerate}}  

\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{definition}[proposition]{Definition}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{cor}[proposition]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{pretheorem}[proposition]{Pretheorem}
\newtheorem{hypothesis}[proposition]{Hypothesis}
\newtheorem{example}[proposition]{Example}
\newtheorem{remark}[proposition]{Remark}
\newtheorem{ex}[proposition]{Exercise}
\newtheorem{cond}[proposition]{Conditions}
\newtheorem{cons}[proposition]{Construction}

%\newcommand{\C}[4]{\left[\begin{array}{rcl}&#1\\#3&\dw\dw&#4\\&#2\end{array}\right]}
\newcommand{\llabel}[1]{\label{#1}[{\bf #1}]}
%\newcommand{\llabel}[1]{\label{#1}}
\newcommand{\comment}[1]{}
\newcommand{\sr}{\rightarrow}
\newcommand{\lr}{\longrightarrow}
\newcommand{\xr}{\xrightarrow}
\newcommand{\dw}{\downarrow}
\newcommand{\bdl}{\bar{\Delta}}
\newcommand{\zz}{{\bf Z\rm}}
\newcommand{\zq}{{\bf Z}_{qfh}}
\newcommand{\nn}{{\bf N\rm}}
\newcommand{\qq}{{\bf Q\rm}}
\newcommand{\nq}{{\bf N}_{qfh}}
\newcommand{\oo}{\otimes}
\newcommand{\uu}{\underline}
\newcommand{\ih}{\uu{Hom}}
\newcommand{\af}{{\bf A}^1}
\newcommand{\wt}{\widetilde}
\newcommand{\gm}{{\bf G}_m}
\newcommand{\dsr}{\stackrel{\sr}{\scriptstyle\sr}}
%\newcommand{\PP}{$P_{\infty}$}
\newcommand{\tp}{\tilde{D}}
\newcommand{\HH}{$H_{\infty}$}
\newcommand{\ii}{\stackrel{\scriptstyle\sim}{\sr}}
\newcommand{\BB}{_{\bullet}}
\newcommand{\D}{\Delta}
\newcommand{\colim}{{\rm co}\hspace{-1mm}\lim}
\newcommand{\cf}{{\it cf} }
\newcommand{\msf}{\mathsf }
\newcommand{\mcal}{\mathcal }
\newcommand{\ep}{\epsilon}
\newcommand{\tl}{\widetilde}
\newcommand{\ub}{\mbox{\rotatebox{90}{$\in$}}}
\newcommand{\ssp}{\,\,\,\,\,\,\,\,}
\newcommand{\red}{\twoheadrightarrow}
\newcommand{\eqg}{\stackrel{\Gamma}{\approx}}
\newcommand{\alphaeq}{\stackrel{\alpha}{\sim}}
\newcommand{\rtr}{\triangleright}

\newcommand{\piece}{\vskip 3mm\noindent\refstepcounter{proposition}{\bf
\theproposition}\hspace{2mm}}
\newcommand{\subpiece}{\vskip 3mm\noindent\refstepcounter{equation}{\bf\theequation}
\hspace{2mm}}{\vskip
3mm}

%% \newcommand{\ev}{{\bf ev}}
\newcommand{\TT}{{\bf Type0}}
\newcommand{\PP}{{\bf Prop}}
\newcommand{\cc}{{\bf c}}
\newcommand{\rect}{{\bf rect}}
\newcommand{\eqd}{\equiv}

\newcommand{\cu}{{u}}
\newcommand{\Eu}{{\cal U}}
\newcommand{\JJ}[2]{{J(#1,#2)\,}}
\newcommand{\J}[1]{{J(#1)\,}}
\newcommand{\jj}[3]{{j(#1,#2,#3)\,}}
\newcommand{\jr}[2]{{jr(#1, #2)\,}}
\newcommand{\jl}[2]{{jl(#1, #2)\,}}
\newcommand{\UU}[1]{{UU(#1)}}
\newcommand{\rd}{\succ}
\newcommand{\rde}{\succeq}
\newcommand{\rdA}{\rd_{\AA}}
\newcommand{\brd}{\equiv}
\newcommand{\ind}{Ind\,\,}
\newcommand{\erd}[1]{\equiv_{{\AA},#1}}
\newcommand{\spc}{{\,\,\,\,\,\,\,}}
\renewcommand{\AA}{{\cal A}}

\newcommand{\ccolon}[1]{\vcentcolon#1}
\newcommand{\ccheck}[1]{\vcentcolon#1}  %\Leftarrow
\newcommand{\synth}[1]{\vcentcolon(\Rightarrow#1)} %\Rightarrow
\renewcommand{\synth}[1]{\ccheck#1} %\Rightarrow

\newcommand{\Type}{\mathop{\text{ \sc type}}}
\newcommand{\Okay}{\mathop{\text{ \sc okay}}}
\newcommand{\Context}{\vdash\Okay}
\renewcommand{\Context}{\vdash}
\newcommand{\ha}[2]{#1[#2]}
\newcommand{\Wrefl}{{\sf Wrefl}}
\newcommand{\weta}{{\sf weta}}
\newcommand{\Wtrans}{{\sf Wtrans}}
\newcommand{\Wsymm}{{\sf Wsymm}}
\newcommand{\El}{{\sf El}}
\newcommand{\annot}{{\sf annot}}
\newcommand{\conv}{{\sf conv}}
\newcommand{\ev}{{\sf ev}}
\newcommand{\wbeta}{{\sf wbeta}}
\newcommand{\weleq}{{\sf weleq}}
\newcommand{\weveq}{{\sf weveq}}
\newcommand{\wl}{{\sf wl}}
\newcommand{\wpi}{{\sf wpi}}
\newcommand{\wsrefl}{{\sf wsrefl}}
\newcommand{\wcrefl}{{\sf wcrefl}}
\newcommand{\wssymm}{{\sf wssymm}}
\newcommand{\wcsymm}{{\sf wcsymm}}
\newcommand{\wstrans}{{\sf wstrans}}
\newcommand{\wctrans}{{\sf wctrans}}
\newcommand{\var}{\char`_}
\newcommand{\defn}{\vcentcolon\equiv}

\begin{document}

\parskip = 2mm
\begin{center}
{\bf\Large A test type system}

{\bf Vladimir Voevodsky}

{Started January 25, 2013}  

{This version modified by Dan Grayson}  
\end{center}

\tableofcontents

This note gives some ideas about the test type system TTS with secondary
witnessed which Dan Grayson and I have been working on implementing. While TTS
by itself has (most likely) decidable definitional equality and typing making
secondary witnesses to be formally speaking unnecessary, they become essential
for the implementation of more complex systems with undecidable typing such as
HTS.

We are aiming at a type system where every derivable extended sentence can be
obtained by a unique inference rules such that one gets a bijection between
inference trees and $\alpha$-equivalence classes of derivable extended
sentences.  The extension is chosen here in a minimal way.

\subsection{Rules}

A {\em judgment} $J$ has one of the following forms:

$$ X \Type $$
$$ X \defn T \Type $$
$$ x \ccolon{T} $$
$$ x \defn t \ccolon{T} $$
$$ w : T \eqd T' $$
$$ w \defn p : T \eqd T' $$
$$ w : t \eqd t' \ccolon{T} $$
$$ w \defn p : t \eqd t' \ccolon{T} $$
$$ J \Rightarrow J' $$

where $X$, $x$, or $w$ is the (single) variable {\em introduced} by the
judgment, where $p$, $t$, $t'$, $T$, $T'$ are expressions, possibly with free
variables, that define values for the variables (as indicated by the operator
$\defn$), and where $J$ and $J'$ are judgments.  The variable introduced by $J$
is regarded as bound in $J'$, and the variable introduced by $J'$ is, in turn,
introduced by $ J \Rightarrow J' $ for possible later use.

A {\em context} or {\em sentence} $\Gamma$ is a list of judgments, each of
which has all of its free variables bound by variables introduced earlier in
the list.  Alternatively, we may say the variable introduced by a judgment in
the list is bound in the remainder of the list.

The witnesses $w$ and $p$ are the additional data that makes these sentences
{\em extended}, and need be recorded only if the derivation tree needs to
recoverable from the derived sentence.

Inference rules given later determine which sentences are well-formed and
derivable.

The notation $$\Gamma \Context$$ will be used to indicate that $\Gamma$ is
well-formed.

Variables introduced by judgments in the context may have names that are
uninteresting for us, if they aren't referred to again.  To indicate that, we
will write the names of such variables as underscores, as in $\var
\ccolon{T_1},\dots,\var \ccolon{T_n}\Context$.

%% In the inference rules below, we'll indicate directionality of type inference
%% in our algorithms by writing
%% $$\Gamma\vdash o \synth{T}$$ to indicate that the type $T$ is produced
%% from the term $o$ and the rest of the information in the sentence by the
%% algorithms, whereas in $$\Gamma\vdash o \ccheck{T}$$ the type $T$ is known and
%% the task is to check that $o$ is of type $T$.  In the former case, one says
%% that $o$ synthesizes its type, and in the latter case, that the type of $o$ is
%% to be checked.  Such directional indications are used for ease of thinking
%% about the correctness, description, and implementation of the algorithms.  The
%% algorithms will necessarily be directional, in that some parts of them will be
%% asked to check that an object has a given type, and other parts of which will
%% be asked to manipulate objects whose type has already been determined.

{\bf Warning}: We intend for certain metatheoretical implications between
judgments to hold.  For example, we expect $\Gamma \vdash p : t \eqd t'
\synth{T}$ would imply that $\Gamma \vdash t \synth{T}$, $\Gamma \vdash t'
\synth{T}$, and $\Gamma \vdash T \Type$, hold, in the sense that the algorithms
described below succeed in checking the statements.

Thanks to Dan Licata for suggestions and advice.

\paragraph{Inference rules} 

\begin{enumerate}

\item
$$\frac{}{\Context}$$

\item
$$\frac{\Gamma,J,J'\Context}{\Gamma,J \Rightarrow J' \Context}$$

\item
$$\frac{\Gamma\Context}{\Gamma, X \Type \Context}$$

This item introduces a variable $X$ representing a family of types parametrized
by the variables of $\Gamma$.  (The semantic meaning is unclear.)

\item
$$\frac{\Gamma, X \defn T \Type \Context}{\Gamma, x \ccolon{T} \Context}$$

This item introduces a variable $x$ of type $T$.  Both are parametrized by the
variables of $\Gamma$.  This is intended to be the standard way to introduce a
proposition $T$ as a hypothesis.

\item
$$\frac{
  \Gamma, X \defn T \Type\Context  
  \spc
  \Gamma, X' \defn T' \Type\Context }
{\Gamma, w : T \eqd T' \Context}$$

This item introduces a hypothesis asserting equality of $T$ and $T'$ witnessed
by the new variable $w$.

\item
$$\frac{
  \Gamma, t \synth{T} \Context
  \spc
  \Gamma, t' \synth{T} \Context
  } {
  \Gamma, w : t \eqd t' \ccolon{T} \Context}$$

This item introduces a hypothesis asserting equality of $t$ and $t'$ witnessed
by the new variable $w$.  (The two occurrences of $T$ in the two premisses
should be equal up to renaming of local variables and expansion of definitions.)

\item 
$$\frac{\Gamma \vdash T \Type\spc \Gamma \vdash T'\Type \spc T\sim T'}{\Gamma\vdash \ha\Wrefl{}: T\eqd T'}$$

Here $T\sim T'$ denotes a comparison operation on terms, which treats certain
conversion and annotation operations specially, as mentioned below.

If $T'$ is obtained from $T$ by removing conversions, it may not be possible to apply
this rule because $T'$ may not be validatable.  Similarly for objects.

\item 
$$\frac{\Gamma\vdash p:T_1\eqd T_2}{\Gamma\vdash \ha\Wsymm{p}:T_2\eqd T_1}$$

We don't list the sentences $ \Gamma \vdash T_1 \Type $ and $ \Gamma \vdash T_2
\Type $ as premisses, but for conversion to LF they would be needed, since each
item would have to be introduced somehow.  This might make this approach more
efficient than using LF.

\item 
$$\frac{\Gamma\vdash p:T_1\eqd T_2\spc\Gamma\vdash q:T_2\eqd T_3}{\Gamma\vdash \ha\Wtrans{p,q,T_2}: T_1\eqd T_3}$$

\item 
$$\frac{\Gamma\vdash o \synth{T}\spc\Gamma\vdash o' \synth{T} \spc o \sim o'}{\Gamma\vdash \ha\wsrefl{}:o\eqd o' \synth{T}}$$

\item 
$$\frac{\Gamma\vdash o \ccheck{T}\spc\Gamma\vdash o' \ccheck{T} \spc o \sim o'}{\Gamma\vdash \ha\wcrefl{}:o\eqd o' \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \synth{T}}{\Gamma\vdash \ha\wssymm{p}:o_2\eqd o_1 \synth{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \ccheck{T}}{\Gamma\vdash \ha\wcsymm{p}:o_2\eqd o_1 \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \synth{T}\spc\Gamma\vdash q:o_2\eqd o_3 \synth{T}}{\Gamma\vdash \ha\wstrans{p,q,o_2}:o_1\eqd o_3 \synth{T}}$$

\item 
$$\frac{\Gamma\vdash p:o_1\eqd o_2 \ccheck{T}\spc\Gamma\vdash q:o_2\eqd o_3 \ccheck{T}}{\Gamma\vdash \ha\wctrans{p,q,o_2}:o_1\eqd o_3 \ccheck{T}}$$

\item 
$$\frac{\Gamma\vdash o \synth{T}\spc \Gamma\vdash q : T \eqd T'}{\Gamma\vdash \ha\conv{o,q} \ccheck{T'}}$$

In any comparisons $T\sim T'$ and $o\sim o'$, a term of the form
$\ha\conv{o,q}$ is regarded as equivalent to $o$.

\item 
$$\frac{\Gamma\vdash o \ccheck{T}}{\Gamma\vdash \ha\annot{o,T} \synth{T}}$$

In any comparisons $T\sim T'$ and $o\sim o'$, a term of the form
$\ha\annot{o,T}$ is regarded as equivalent to $o$.

In the code, the term $\ha\annot{o,T}$ could be represented by a private data
type, so that such terms can be created only by the kernel of the type checker,
and so no tactic could forge such a certificate.

\end{enumerate}

\paragraph{Universe}

\begin{enumerate}

\item

$$\frac{\Gamma\Context}{\Gamma \vdash \Eu\Type}$$

\item

$$\frac{\Gamma\vdash o \synth{\Eu}}{\Gamma \vdash \ha\El{o}\Type}$$

Later on, there will a universe level, and it will be computable from the
term $o$, hence the choice of direction in this rule.

\item 

$$\frac{\Gamma\vdash p : o \eqd o' \synth{\Eu}}{\Gamma\vdash \ha\weleq{p} : \ha\El{o} \eqd \ha\El{o'}}$$

When universe levels are added, the universe level synthesized here will be the
larger of those synthesized from $o$ and $o'$.

\end{enumerate}

\paragraph{Dependent products}

\begin{enumerate}

\item 
$$\frac{\Gamma \vdash T \Type \spc \Gamma, \var \ccolon{T}\vdash U\Type}{\Gamma\vdash \ha\prod{T,.U}\Type}$$

Here $.U$ is notation for abstraction: binding a variable to the scope of the expression $U$.

\item 
$$ \frac{ 
  \Gamma, \var \ccolon{T'} \vdash U'  \Type      \spc 
  \Gamma     \vdash p:T \eqd T'    \spc
  \Gamma,  \var \ccolon{T}  \vdash q:U \eqd p^*U'
  } {
  \Gamma     \vdash \ha\wpi{p,q}:\ha\prod{T,.U}\eqd \ha\prod{T',.U'}
}$$

Here ${p}^*U'$ is notation for $U'[\ha\annot{\ha\conv{\#0,p},T'}/\#0]$, where
$U'[e/\#0]$ is notation for replacing the first variable in $U'$ by $e$, and
where any $\#0$ occuring in $e$ denotes the first variable in the resulting
term.

\item 
$$\frac{\Gamma \vdash T \Type \spc \Gamma, \var \ccolon{T}\vdash o \ccheck{U}}{\Gamma\vdash \ha\lambda{.o} \ccheck{\ha\prod{T,.U}}}$$

Some space is saved by not annotating $\ha\lambda{.o}$ with $T$ and $.U$.

\item 
$$\frac{\Gamma \vdash T \Type \spc \Gamma, \var \ccolon{T}\vdash p : o\eqd o' \ccheck{U}}{\Gamma\vdash \ha\wl{p} : \ha\lambda{.o}\eqd \ha\lambda{.o'} : \ha\prod{T,.U}}$$

\item 
$$\frac{\Gamma\vdash f \ccolon{\ha\prod{T,.U}}\spc \Gamma\vdash t \ccheck{T}}{\Gamma\vdash \ha\ev{f,t} \synth{U[\ha\annot{t,T}]}}$$

Here $U[o]$ is notation for replacing the first variable of $U$ by $o$, with
the second variable of $U$ becoming the first, and so on.  

The annotation is present to ensure that the sentence $\Gamma \vdash
U[\ha\annot{t,T}] \Type$ is checkable.

Some space is saved by not annotating $\ha\ev{f,o}$ with $T$ and $.U$, due to
bidirectionality.  The same applies to such expressions as $x.y.z.f\, x\, y\,
z$, where $f$ synthesizes its type.

\item 
$$\frac{
   \Gamma\vdash p : f \eqd f' \synth{\ha\prod{T,.U}}\spc 
   \Gamma\vdash q : t \eqd t' \ccheck{T}
   }{
   \Gamma\vdash \ha\weveq{p,q} : \ha\ev{f,t} \eqd \ha\ev{f',t'} \synth{U[\ha\annot{t,T}]}
  }$$

For simplicity, assume that $f'$ is $f$, and observe that $\Gamma \vdash
\ha\ev{f',t'} \synth{U[\ha\annot{t,T}]}$ may not be valid, even though $\Gamma
\vdash \ha\ev{f',t'} \synth{U[\ha\annot{t',T}]}$ is.  Nevertheless, $\Gamma \vdash
\ha\ev{f',t'} : U[\ha\annot{t,T}]$ is valid in the underlying type theory where
the witnesses have been forgotten.

\item 
% beta
$$\frac{ \Gamma \vdash T \Type \spc \Gamma\vdash t \ccheck{T}\spc \Gamma, \var \ccolon{T}\vdash u \ccheck{U}}{\Gamma\vdash \ha\wbeta{T,.U} : \ha\ev{\ha\lambda{.u},t} \eqd u[\ha\annot{t,T}] : U[\ha\annot{t,T}]}$$

Replacing $\ha\lambda{.u}$ by $\ha\annot{\ha\lambda{.u},\ha\prod{T,.U}}$ would
be an alternative to putting $T$ and $.U$ in the witness.  Comparison of two
terms of the same type by normalization need not involve computation of the
types of partially applied results, so a version of this rule free of type
annotations is needed.

It would be better if $\beta$-reduction were free-running, without the
necessity of tracking the types $T$ and $U$.

% eta
\item 
$$\frac{\Gamma\vdash f \ccheck{\ha\prod{T,.U}}}{\Gamma\vdash \ha\weta{} : f \eqd \ha\lambda{x.\ha\ev{f,x}} : \ha\prod{T,.U}}$$ 

\end{enumerate}

\bibliography{alggeom}
\bibliographystyle{plain}
\end{document}
  %% Local Variables:
  %% compile-command: "pdflatex TTS-internal-witnesses.tex "
  %% End:

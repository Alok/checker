\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amscd, amssymb}
\usepackage{enumerate}
\usepackage{mathtools}          %to get \vcentcolon
\usepackage{mathpartir}
\input xy \xyoption{all} \CompileMatrices

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parindent = 0.0in

\renewcommand{\thesubsection}{\arabic{subsection}}

\newenvironment{eq}{\begin{equation}}{\end{equation}}

\newenvironment{proof}{{\bf Proof}:}{\vskip 5mm }
\newenvironment{rem}{{\bf Remark}:}{\vskip 5mm }
\newenvironment{remarks}{{\bf Remarks}:\begin{enumerate}}{\end{enumerate}}
\newenvironment{examples}{{\bf Examples}:\begin{enumerate}}{\end{enumerate}}  

\newtheorem{proposition}{Proposition}[subsection]
\newtheorem{lemma}[proposition]{Lemma}
\newtheorem{definition}[proposition]{Definition}
\newtheorem{theorem}[proposition]{Theorem}
\newtheorem{cor}[proposition]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{pretheorem}[proposition]{Pretheorem}
\newtheorem{hypothesis}[proposition]{Hypothesis}
\newtheorem{example}[proposition]{Example}
\newtheorem{remark}[proposition]{Remark}
\newtheorem{ex}[proposition]{Exercise}
\newtheorem{cond}[proposition]{Conditions}
\newtheorem{cons}[proposition]{Construction}

%\newcommand{\C}[4]{\left[\begin{array}{rcl}&#1\\#3&\dw\dw&#4\\&#2\end{array}\right]}
\newcommand{\llabel}[1]{\label{#1}[{\bf #1}]}
%\newcommand{\llabel}[1]{\label{#1}}
\newcommand{\comment}[1]{}
\newcommand{\sr}{\rightarrow}
\newcommand{\lr}{\longrightarrow}
\newcommand{\xr}{\xrightarrow}
\newcommand{\dw}{\downarrow}
\newcommand{\bdl}{\bar{\Delta}}
\newcommand{\zz}{{\bf Z\rm}}
\newcommand{\zq}{{\bf Z}_{qfh}}
\newcommand{\nn}{{\bf N\rm}}
\newcommand{\qq}{{\bf Q\rm}}
\newcommand{\nq}{{\bf N}_{qfh}}
\newcommand{\oo}{\otimes}
\newcommand{\uu}{\underline}
\newcommand{\ih}{\uu{Hom}}
\newcommand{\af}{{\bf A}^1}
\newcommand{\wt}{\widetilde}
\newcommand{\gm}{{\bf G}_m}
\newcommand{\dsr}{\stackrel{\sr}{\scriptstyle\sr}}
%\newcommand{\PP}{$P_{\infty}$}
\newcommand{\tp}{\tilde{D}}
\newcommand{\HH}{$H_{\infty}$}
\newcommand{\ii}{\stackrel{\scriptstyle\sim}{\sr}}
\newcommand{\BB}{_{\bullet}}
\newcommand{\D}{\Delta}
\newcommand{\colim}{{\rm co}\hspace{-1mm}\lim}
\newcommand{\cf}{{\it cf} }
\newcommand{\msf}{\mathsf }
\newcommand{\mcal}{\mathcal }
\newcommand{\ep}{\epsilon}
\newcommand{\tl}{\widetilde}
\newcommand{\ub}{\mbox{\rotatebox{90}{$\in$}}}
\newcommand{\ssp}{\,\,\,\,\,\,\,\,}
\newcommand{\red}{\twoheadrightarrow}
\newcommand{\eqg}{\stackrel{\Gamma}{\approx}}
\newcommand{\alphaeq}{\stackrel{\alpha}{\sim}}
\newcommand{\rtr}{\triangleright}

\newcommand{\piece}{\vskip 3mm\noindent\refstepcounter{proposition}{\bf
\theproposition}\hspace{2mm}}
\newcommand{\subpiece}{\vskip 3mm\noindent\refstepcounter{equation}{\bf\theequation}
\hspace{2mm}}{\vskip
3mm}

\newcommand{\TT}{{\bf Type0}}
\newcommand{\PP}{{\bf Prop}}
\newcommand{\cc}{{\bf c}}
\newcommand{\rect}{{\bf rect}}
\newcommand{\syndef}{\equiv}
\newcommand{\equality}{=}
\newcommand{\identity}{\sim}

\newcommand{\Univ}{{\cal U}}
\newcommand{\univ}{\upsilon}
\newcommand{\funiv}{\upsilon^F}
\newcommand{\FUniv}{{\cal U}^F}
\newcommand{\UU}[1]{{UU(#1)}}

\newcommand{\hastype}{\vcentcolon}

\newcommand{\TYPE}{\mathop{\text{ \sc type}}}
\newcommand{\FTYPE}{\mathop{\text{ \sc type}^F}}
\newcommand{\Type}{\mathop{\text{Type}}}
\newcommand{\Context}{\vdash}
\newcommand{\ha}[2]{#1[#2]}
\newcommand{\refl}{{\sf refl}}
\newcommand{\Wrefl}{{\sf Wrefl}}
\newcommand{\weta}{{\sf weta}}
\newcommand{\JJ}{{\sf J}}
\newcommand{\Wtrans}{{\sf Wtrans}}
\newcommand{\Wsymm}{{\sf Wsymm}}
\newcommand{\El}{{\sf El}}
\newcommand{\tprod}{\Pi}
\newcommand{\annot}{{\sf annot}}
\newcommand{\haa}[2]{\ha\annot{#1,#2}}
\renewcommand{\haa}[2]{#1}
\newcommand{\conv}{{\sf conv}}
\newcommand{\wconv}{{\sf wconv}}
\newcommand{\ev}{{\sf ev}}
\newcommand{\wbeta}{{\sf wbeta}}
\newcommand{\weleq}{{\sf weleq}}
\newcommand{\welfeq}{{\sf welfeq}}
\newcommand{\welequ}{{\sf welequ}}
\newcommand{\welfequ}{{\sf welfequ}}
\newcommand{\weveq}{{\sf wev}}
\newcommand{\wsubeq}{{\sf wsubeq}}
\newcommand{\wlambda}{{\sf wlambda}}
\newcommand{\Wsubst}{{\sf Wsubst}}
\newcommand{\wsubst}{{\sf wsubst}}
\newcommand{\wpieq}{{\sf wpi}}
\newcommand{\uep}{{\sf uep}}
\newcommand{\wrefl}{{\sf wrefl}}
\newcommand{\Wid}{{\sf Wid}}
\newcommand{\wJ}{{\sf wJ}}
\newcommand{\wsymm}{{\sf wsymm}}
\newcommand{\wtrans}{{\sf wtrans}}
\newcommand{\windo}{{\sf windo}}
\newcommand{\windeq}{{\sf windeq}}
\newcommand{\winds}{{\sf winds}}
\newcommand{\wetaN}{{\sf wetaN}}
\newcommand{\wetatN}{{\sf wetatN}}
\newcommand{\succN}{{\sf succ}}
\newcommand{\zeroN}{{\sf zero}}
\newcommand{\var}{\char`_}
\newcommand{\defn}{\vcentcolon=}
\newcommand{\NN}{\mathbb N}
%\newcommand{\UNIV}{\mathop{\text{ \sc univ}}}
\newcommand{\UNIV}{\hastype \NN}
\newcommand{\indN}{{\sf ind}_\NN}
\newcommand{\indtN}{{\sf indt}_\NN}

\begin{document}

\parskip = 2mm
\begin{center}
{\bf\Large A test type system}

{\bf Vladimir Voevodsky}

{Started January 25, 2013}  

{This version modified heavily by Dan Grayson}  
\end{center}

\tableofcontents

This note gives some ideas about the test type system TTS with secondary
witnessed which Dan Grayson and I have been working on implementing. While TTS
by itself has (most likely) decidable definitional equality and typing making
secondary witnesses to be formally speaking unnecessary, they become essential
for the implementation of more complex systems with undecidable typing such as
HTS.

We are aiming at a type system where every derivable extended sentence can be
obtained by a unique inference rules such that one gets a bijection between
inference trees and $\alpha$-equivalence classes of derivable extended
sentences.  The extension is chosen here in a minimal way.

\subsection{Rules}

A {\em context entry} $J$ has one of the following forms:

$$ x \hastype T $$
$$ x \defn t \hastype T $$
$$ X \TYPE $$
$$ X \defn T \TYPE $$
$$ X \FTYPE $$
$$ X \defn T \FTYPE $$

where $x$ or $X$ is the variable {\em introduced} by the context entry, and
where $t$ and $T$ are expressions, possibly with free variables, that {\em
  define} values for the variables (as indicated by the operator $\defn$).  The
form $\FTYPE$ is used to distinguish types that are {\em fibrant}.

A {\em context} or {\em sentence} $\Gamma$ is a list of context entries, each of
which has all of its free variables bound by variables introduced earlier in
the list.  Alternatively, we may say the variable introduced by a context entry in
the list is bound in the remainder of the list.

Inference rules given later determine which sentences are well-formed and
derivable.  The notation $$\Gamma \Context$$ will be used to indicate that
$\Gamma$ is well-formed.

Syntactic equality between expressions occurring twice in the conclusion of an
inference rule will be up to renaming of local variables, expansion of
definitions, and a few other rules, to be presented later, that amount to
ignoring certain subexpressions during equality checking.  We use the notation
$ t \equiv t' $ for syntactic equality.

The last variable introduced by a context is always unused, so we may 
abbreviate the sentence
$$ \Gamma, x \defn t \hastype T \Context $$ by
$$ \Gamma \vdash t \hastype T $$
and
$$ \Gamma, X \defn T \TYPE \Context $$ by
$$ \Gamma \vdash T \TYPE $$
and
$$ \Gamma, X \defn T \FTYPE \Context $$ by
$$ \Gamma \vdash T \FTYPE. $$

The hypotheses {\em active} in a context $\Gamma$ are the variables with no
defined value.

Variables introduced by context entries in the context may have names that are
uninteresting for us, if they aren't referred to again.  To indicate that, we
will write the names of such variables as underscores, as in $\var
\hastype T_1,\dots,\var \hastype T_n\Context$.

Putting defined values explicitly into the context allows us to identify a map
$$ [ x_1 : T_1 , \dots , x_m : T_m ] \xrightarrow u [ y_1 : U_1 , \dots , y_n : U_n ] $$
in the contextual category with the projection map
$$ [ x_1 : T_1 , \dots , x_m : T_m, y_1 \defn u_1 : U_1 , \dots , y_n \defn u_n
  : U_n ] \xrightarrow u [ y_1 : U_1 , \dots , y_n : U_n ]$$  from the graph of
$u$, provided we
regard variables with defined values as mere annotations, rather than as
coordinates
with specified values, thereby rendering the other projection map 
$$\xymatrix{[ x_1 : T_1 , \dots , x_m : T_m, y_1 \defn u_1 : U_1 , \dots , y_n \defn u_n
  : U_n ] \ar[d]^1 \\ [ x_1 : T_1 , \dots , x_m : T_m]} $$ an identity map.
That is convenient, because of its compact form, without multiple
explicit substitutions.  Moreover, a canonical pullback square has the form
\[\xymatrix{
[ x_1 : T_1 , \dots , x_m : T_m, y_1 \defn u_1 : U_1 , \dots , y_n \defn u_n : U_n, z : V ] \ar[r] \ar[d] &
[ y_1 : U_1 , \dots , y_n : U_n, z:V ] \ar[d] \\
[ x_1 : T_1 , \dots , x_m : T_m ] \ar[r]^u &
[ y_1 : U_1 , \dots , y_n : U_n ]
}.\]
Introducing a type that serves as definitional equality and can thus be placed in the context, as we will do, will allow us
to produce arbitrary pullbacks in the contextual category.

Thanks to Dan Licata and Peter Lumsdaine for suggestions and advice.

\paragraph{Inference rules} 

\begin{enumerate}

\item
\[\inferrule{\ }{\Context}\]

\item
The effect of defined values:
\begin{mathparpagebreakable}
\inferrule{\Gamma,x \defn t \hastype Q,\Gamma'\Context}{\Gamma,x \defn t \hastype Q,\Gamma' \vdash x \syndef t}\and
\inferrule{\Gamma,x:Q,\Gamma'\Context}{\Gamma,x:Q,\Gamma',y\defn x : Q \Context}\and
\inferrule{\Gamma,x \defn p :Q,\Gamma'\Context}{\Gamma,x \defn p :Q,\Gamma',y\defn x : Q \Context}\and
\end{mathparpagebreakable}

Here (and below) $Q$ represents the tail end of a context entry, not including
the variable or its defined value.  For example, a special case of one of these rules is the following one.

\[\inferrule{\Gamma,x:T,\Gamma'\Context}{\Gamma,x:T,\Gamma' \vdash x : T}\]

\item
\[\inferrule{\Gamma, x:Q,\Gamma' \Context \\ \Gamma, x \defn t:Q \Context}{\Gamma, x \defn t:Q,\Gamma'\Context}\]

For example, special cases of this rule are the following ones.

\[\inferrule{\Gamma, X \TYPE,\Gamma' \Context \\ \Gamma \vdash T \Type}{\Gamma, X \defn T \TYPE, \Gamma'\Context}\]

\[\inferrule{\Gamma, x:T,\Gamma' \Context \\ \Gamma \vdash t:T}{\Gamma, x \defn t:T,\Gamma'\Context}\]

\item
If the variable $x$ does not appear in $\Gamma'$, then

\[\inferrule{\Gamma,x\hastype Q,\Gamma'\Context}{\Gamma,\Gamma' \Context }\]

and

\[\inferrule{\Gamma, x\defn t\hastype Q,\Gamma'\Context}{\Gamma,\Gamma' \Context }\]

In the latter rule, observe that since we are working modulo unfolding of
definitions, $\Gamma'$ can always be replaced by something that doesn't involve
$x$; that amounts to substituting $t$ for $x$ in $\Gamma'$.

\item
\[\inferrule{
  \Gamma \vdash T \TYPE  
  \\
  \Gamma \vdash T' \TYPE }
{\Gamma \vdash T \equality T' \TYPE}\]

This inference rule introduces a type called $T \equality T'$.  It will serve as
the mathematical notion of exact equality between types.

\item
  \[\inferrule{
  \Gamma \vdash p \hastype  T \equality T'
  \\
  \Gamma \vdash t \hastype T
  \\
  \Gamma \vdash t' \hastype T'
  } {
  \Gamma \vdash t \equality t' \hastype p : T \equality T' \TYPE}\]

This inference rule introduces a type called $t \equality t' \hastype p : T \equality
T'$.  It will serve as the mathematical notion of exact equality between
objects of equal types.  In the case where $T$ and $T'$ are the same and $p$ is $\ha\Wrefl{}$, we will
abbreviate it to $t \equality t' \hastype T$.  Syntactic comparison of
expressions representing two such types will ignore the expressions $p$.

\item
The following rules are included, because they correspond to meta-theorems that
we intend should hold; they are not expected to be useful in constructing
proofs, and they shouldn't participate in derivations considered by the
uniqueness statement of the introduction.  They should be thought of as sanity
checks.

\begin{mathparpagebreakable}
  \inferrule{\Gamma \vdash t \hastype T}
       {\Gamma, \var \hastype T \Context}
  \and
  \inferrule{\Gamma, \var \hastype T \Context}
       {\Gamma \vdash T \TYPE}
  \and
  \inferrule{\Gamma \vdash p \hastype T \equality T'}
       {\Gamma, \var \hastype T \equality T' \Context}
  \and
  \inferrule{\Gamma, \var \hastype T \equality T' \Context}
       {\Gamma \vdash T \TYPE}
  \and
  \inferrule{\Gamma, \var \hastype T \equality T' \Context}
       {\Gamma \vdash T' \TYPE}
  \and
  \inferrule{\Gamma \vdash p : t \equality t' \hastype q : T \equality T'}
       {\Gamma, \var : t \equality t' \hastype q : T \equality T' \Context}
  \and
  \inferrule{\Gamma, \var : t \equality t' \hastype q : T \equality T' \Context}
       {\Gamma \vdash t \hastype T}
  \and
  \inferrule{\Gamma, \var : t \equality t' \hastype q : T \equality T' \Context}
       {\Gamma \vdash t' \hastype T'}
  \and
  \inferrule{\Gamma, \var : t \equality t' \hastype q : T \equality T' \Context}
       {\Gamma \vdash q : T \equality T'}

\end{mathparpagebreakable}

\item 
Equal types have equal elements:
\begin{mathparpagebreakable}
\inferrule
    { \Gamma \vdash t \hastype T \\ \Gamma \vdash p \hastype  T \equality T'}
    { \Gamma \vdash \ha\conv{t,T,p} \hastype T' }
\and
\inferrule
    { \Gamma \vdash t \hastype T \\ \Gamma \vdash p \hastype  T \equality T' }
    { \Gamma \vdash \ha\wconv{} \hastype t \equality \ha\conv{t,T,p} \hastype p : T \equality T'}\and
\end{mathparpagebreakable}


\item
Conversion is ignored when checking syntactic equality.

\begin{mathparpagebreakable}
\inferrule
    { \Gamma \vdash t_1 \syndef t_2}
    { \Gamma \vdash \ha\conv{t_1,T_1,p_1} \syndef t_2 }\and
\inferrule
    { \Gamma \vdash t_1 \syndef t_2}
    { \Gamma \vdash t_1 \syndef \ha\conv{t_2,T_2,p_2} }\and
\end{mathparpagebreakable}

We don't intend to imply that a subexpression can be replaced by anything
syntactically equal to it, for then automatic typechecking of the resulting
expression may fail.

\item
Proofs of equality between types are equal:
\[\inferrule
{\Gamma \vdash p \equality p' \hastype q : (T_1 \equality T'_1) \equality (T_2 \equality T'_2) \TYPE}
{\Gamma \vdash \ha\uep{} \hastype p \equality p' \hastype q : (T_1 \equality T'_1) \equality (T_2 \equality T'_2)}
\]

Proofs of equality between objects are equal:
\[\inferrule
{\Gamma \vdash p \equality p' \hastype (t_1 \equality t'_1 \hastype q_1 : T_1 \equality T'_1) \equality (t_2 \equality t'_2 \hastype q_2 : T_2 \equality T'_2) \TYPE}
{\Gamma \vdash \ha\uep{} \hastype p \equality p' \hastype (t_1 \equality t'_1 \hastype q_1 : T_1 \equality T'_1) \equality (t_2 \equality t'_2 \hastype q_2 : T_2 \equality T'_2)}
\]

Maybe it is better to implement this at a lower level, by implementing $t \equiv t'$ so that
$ p \equiv p' $ is always true.

Or maybe, as Voevodsky indicates, these rules can be derived by induction and reflection.

\item 
\[\inferrule{\Gamma \vdash T \equality T' \TYPE \\ \Gamma \vdash T \syndef T'}
       {\Gamma \vdash \ha\Wrefl{}\hastype  T\equality T'}
\]

\item 
\[\inferrule{\Gamma \vdash p\hastype T_1\equality T_2 }{\Gamma \vdash \ha\Wsymm{p}\hastype T_2\equality T_1}\]

\item 
\[
  \inferrule{
    \Gamma \vdash p\hastype T_1\equality T_2
    \\
    \Gamma \vdash q\hastype T_2\equality T_3
  }
  {\Gamma \vdash \ha\Wtrans{p,T_2,q}\hastype  T_1\equality T_3 }
\]

\item 
\[\inferrule{
  \Gamma \vdash o \equality o' \hastype \ha\Wrefl{} : T \equality T' \TYPE
  \\
  \Gamma \vdash o \syndef o'
  } {
  \Gamma \vdash  \ha\wrefl{}\hastype  o \equality o' \hastype \ha\Wrefl{} : T \equality T'
  } 
\]

Or maybe we can just {\em define} $\ha\wrefl{}$ to be $\ha\wconv{}$.

\item 
\[\inferrule
    {\Gamma \vdash p\hastype o_1\equality o_2 \hastype \tilde p : T_1 \equality T_2}
    {\Gamma \vdash \ha\wsymm{p}\hastype o_2\equality o_1 \hastype \ha\Wsymm{\tilde p} : T_2 \equality T_1}\]

\item 
\[\inferrule{\Gamma \vdash p\hastype o_1\equality o_2 \hastype \tilde p : T_1 \equality T_2
  \\
  \Gamma \vdash q\hastype o_2\equality o_3 \hastype \tilde q : T_2 \equality T_3
  } {
  \Gamma \vdash \ha\wtrans{p,o_2,q}\hastype o_1\equality o_3 \hastype \ha\Wtrans{\tilde p,T_2,\tilde q} : T_1 \equality T_3}
\]

\item
  Propagation of equality through substitution.
\[\inferrule{ 
  \Gamma, \var \hastype T \vdash U \TYPE \\
  \Gamma \vdash p \hastype t \equality t' \hastype \Wrefl[] : T \equality T
}{
  \Gamma \vdash \wsubeq[T,.U,t,t',p] \hastype U[t] \equality U[t']
}\]

\item
Universes.

\begin{mathparpagebreakable}
\inferrule{\Gamma\vdash n \UNIV}{ \Gamma \vdash \Univ_n \FTYPE} \and
\inferrule{\Gamma\vdash n \UNIV}{ \Gamma \vdash \FUniv_n \FTYPE} \and
\inferrule{ \Gamma \vdash o \hastype{\Univ_n}} { \Gamma \vdash \ha\El{n,o}\TYPE } \and
\inferrule{ \Gamma \vdash o \hastype{\FUniv_n}} { \Gamma \vdash \ha\El{n,o}\FTYPE } \and
\inferrule{ \Gamma \vdash t \syndef t' }{ \Gamma \vdash \ha\El{n,t} \syndef \ha\El{n',t'} } \and
\inferrule{\Gamma \vdash n \UNIV  } {\Gamma \vdash \univ_n \hastype  \FUniv_{\ha\succN n}  } \and
\inferrule{\Gamma \vdash n \UNIV  } {\Gamma \vdash \funiv_n \hastype  \FUniv_{\ha\succN n} } \and
\inferrule{\Gamma \vdash n \UNIV  } {\Gamma \vdash \ha\welequ{} \hastype \Univ_n \equality \ha\El{\ha\succN n, \univ_n} } \and
\inferrule{\Gamma \vdash n \UNIV  } {\Gamma \vdash \ha\welfequ{} \hastype \FUniv_n \equality \ha\El{\ha\succN n, \funiv_n} } \and

\end{mathparpagebreakable}

\item
General and fibrant types.
\begin{mathparpagebreakable}
\inferrule{ \Gamma \vdash T \FTYPE }
          { \Gamma \vdash T \TYPE } \and
\inferrule{ \Gamma \vdash o \hastype{\FUniv_n} }
          { \Gamma \vdash o \hastype{\Univ_n} } \and
\inferrule{ \Gamma \vdash o \hastype{\Univ_n}}
          { \Gamma \vdash o \hastype{\Univ_{\ha\succN n}}} \and
\inferrule{ \Gamma \vdash o \hastype{\FUniv_n}}
          { \Gamma \vdash o \hastype{\FUniv_{\ha\succN n}}} \and
\end{mathparpagebreakable}

\item
Equality and $\El$.
\[\inferrule{\Gamma \vdash p \hastype  o \equality o' \hastype q : \Univ_n \equality \Univ_{n'}} 
          {\Gamma \vdash \ha\weleq{p,q} \hastype  \ha\El{n,o} \equality \ha\El{n',o'}}
\]

\item 
\[\inferrule{ \Gamma, \var \hastype T \vdash U\TYPE  }{\Gamma \vdash \ha\tprod{T,.U}\TYPE}\]

Here $.U$ is notation for abstraction: binding an anonymous variable to the
expression $U$; we will also use the notation $x.U$ when binding a named
variable $x$, as in the following equivalent version of the same rule.

\[\inferrule{ \Gamma, x \hastype T \vdash U\TYPE  }
       {\Gamma \vdash \ha\tprod{T,x.U}\TYPE}\]

\item 
\[\inferrule{
  \Gamma \vdash T \FTYPE \\
  \Gamma, \var \hastype T \vdash U \FTYPE  
}{
  \Gamma \vdash \ha\tprod{T,.U} \FTYPE
}\]

\item 
\[\inferrule{
  \Gamma, \var \hastype T \vdash u \hastype{U}
}{\Gamma \vdash \ha\lambda{.u} \hastype{\ha\tprod{T,.U}}}
\]

\item 
\[ \inferrule{ 
  \Gamma \vdash p\hastype T \equality T'  \\
  \Gamma, x \hastype T, x' \hastype T', \var \hastype  x \equality x' \hastype p : T \equality T' \vdash q \hastype  U \equality U' 
  } {
  \Gamma \vdash \ha\wpieq{p,...q}\hastype \ha\tprod{T,x.U}\equality \ha\tprod{T',x'.U'}
}\]

\item 
\[ \inferrule{ 
  \Gamma \vdash p\hastype T \equality T' \\
  \Gamma, x \hastype T, x' \hastype T', \var \hastype  x \equality x' \hastype p : T \equality T' \vdash q \hastype  u \equality u' \hastype \tilde q : U \equality U'
  } {
  \Gamma \vdash \ha\wlambda{...q} \hastype  \ha\lambda{.u}\equality \ha\lambda{.u'} \hastype \ha\wpieq{p,...\tilde q} :  \ha\tprod{T,.U} \equality \ha\tprod{T',.U'}
}\]

\item 
\[\inferrule{
  \Gamma \vdash f \hastype{\ha\tprod{T,.U}}
  \\ 
  \Gamma \vdash t \hastype{T}
  \\
  \Gamma \vdash U' \syndef U[\haa t T] 
}{
  \Gamma \vdash \ha \ev{f,t,{\ha\tprod{T,.U}}} \hastype U'
}\]

\item 
\[\inferrule{
   \Gamma, x \hastype T \vdash U \TYPE \\
   \Gamma, x' \hastype T' \vdash U' \TYPE \\
   \Gamma \vdash p\hastype T \equality T'  \\
   \Gamma, x \hastype T, x' \hastype T', \var \hastype  x \equality x' \hastype p : T \equality T' \vdash q \hastype  U \equality U' 
   \\
   \Gamma \vdash r \hastype  f \equality f' \hastype \ha\wpieq{p,...q} : {\ha\tprod{T,.U}} \equality {\ha\tprod{T',.U'}} 
   \\ 
   \Gamma \vdash s \hastype  t \equality t' \hastype p : T \equality T'
   }{
   \Gamma \vdash \ha\weveq{p,...q,r,s} \hastype  \ha\ev{f,t,{\ha\tprod{T,.U}}} \equality \ha\ev{f',t',{\ha\tprod{T',.U'}}} \hastype q[t,t',s] : U[\haa t T] \equality U'[\haa {t'} {T'}]
  }\]

\item 
% beta
\[\inferrule{
  \Gamma \vdash \ha\lambda{.u} \hastype {\ha\tprod{T,.U}}
  \\
  \Gamma \vdash t \hastype{T} 
  }{
  \Gamma \vdash \ha\wbeta{} \hastype  \ha\ev{\ha\lambda{.u},t,{\ha\tprod{T,.U}}} \equality u[\haa{t}{T}] \hastype  U[\haa{t}{T}]
}\]

%% Replacing $\ha\lambda{.u}$ by $\haa{\ha\lambda{.u}}{\ha\tprod{T,.U}}$ would
%% be an alternative to putting $T$ and $.U$ in the witness.  Comparison of two
%% terms of the same type by normalization need not involve computation of the
%% types of partially applied results, so a version of this rule free of type
%% annotations is needed.

%% (It would be better if $\beta$-reduction were free-running, without the
%% necessity of tracking the types $T$ and $U$.)

% eta
\item 
\[
  \inferrule{\Gamma \vdash f \hastype{\ha\tprod{T,.U}}}
       {\Gamma \vdash \ha\weta{} \hastype  f \equality \ha\lambda{t.\ha\ev{f,t,{\ha\tprod{T,.U}}}} \hastype  \ha\tprod{T,.U}
       }
\]

\item\ 
\begin{mathparpagebreakable}
  \inferrule{\Gamma \Context}
       {\Gamma \vdash \NN \FTYPE }
  \and
  \inferrule{\Gamma \Context}
       {\Gamma \vdash \zeroN \hastype \NN }
  \and
  \inferrule{ \Gamma \vdash n \hastype \NN }
       {\Gamma \vdash \ha \succN {n} \hastype \NN }
\end{mathparpagebreakable}

\item
\[
\inferrule{
  \Gamma \vdash b \hastype T[\zeroN]
  \\
  \Gamma, n \hastype \NN, c \hastype T \vdash d \hastype T[\succN[n]]
  \\
  \Gamma \vdash n \hastype \NN
}
     {\Gamma \vdash \ha\indN{.T,b,..d,n} \hastype  T[n] }
\]

\item
\[
\inferrule{
  \Gamma \vdash b \hastype T[\zeroN]
  \\
  \Gamma, n \hastype \NN, c \hastype T \vdash d \hastype T[\succN[n]]
}
     {\Gamma \vdash \ha\windo{} \hastype  \ha\indN{.T,b,..d,\zeroN} \equality b \hastype  T[\zeroN] }
\]

\item
\[
\inferrule{
  \Gamma \vdash b \hastype T[\zeroN]
  \\
  \Gamma, n \hastype \NN, c \hastype T \vdash d \hastype T[\succN[n]]
  \\
  \Gamma \vdash n \hastype \NN
}
     {\Gamma \vdash \ha\winds{} \hastype  \ha\indN{.T,b,..d,\succN[n]} \equality d[n,\ha\indN{.T,b,..d,n}] \hastype  T[\succN[n]] }
\]

\item
\[
\inferrule{
  \Gamma, n \hastype \NN \vdash p \hastype  T \equality T'
  \\
  \Gamma \vdash q \hastype  b \equality b' \hastype p[\zeroN] : T[\zeroN] \equality T'[\zeroN]
  \\
  \Gamma, n \hastype \NN, c \hastype T[n] \vdash d \hastype T[\succN[n]]
  \\
  \Gamma, n \hastype \NN, c' \hastype T'[n] \vdash d' \hastype T'[\succN[n]]
  \\
  \Gamma, n \hastype \NN, \var \hastype  c \equality c' \hastype p[n] : T[n] \equality T'[n] \vdash r \hastype  d[n,c] \equality d'[n,c'] \hastype p[\succN[n]] : T[\succN[n]] \equality T'[\succN[n]]
  \\
  \Gamma \vdash s \hastype  n \equality n' \hastype \NN
}
     {\Gamma \vdash \ha\windeq{.p,q,..r,s} \hastype  \ha\indN{.T,b,..d,n} \equality \ha\indN{.T',b',..d',n'} \hastype {\rm ????} : T[n] \equality T'[n'] }
\]

One way to fill in the question marks would be to replace the premise $$\Gamma, n \hastype \NN \vdash p \hastype  T \equality T'$$ by the premise $$\Gamma, n \hastype \NN, n' \hastype \NN, z \hastype n \equality n' \hastype \NN \vdash p \hastype  T \equality T',$$ for then we could fill in the question marks with $p[n,n',s]$.  We would also replace instances of $p[m]$ with $p[m,m,\ha\wrefl{}]$.

\item
Identity type.
\begin{mathparpagebreakable}
  \inferrule{\Gamma \vdash T \FTYPE \\ \Gamma \vdash t_1 \hastype T \\ \Gamma \vdash t_2 \hastype T}
            {\Gamma \vdash (t_1 \identity t_2 \hastype T) \FTYPE} 
  \and
  \inferrule{\Gamma \vdash T \FTYPE \\ \Gamma \vdash t \hastype T}
            {\Gamma \vdash \ha\refl{} \hastype t \identity t \hastype T}
  \and
  \inferrule{
    \Gamma \vdash T \FTYPE \\ 
    \Gamma, x_1 \hastype T, x_2 \hastype T, e \hastype x_1 \identity x_2 \hastype T \vdash P \FTYPE \\
    \Gamma, x \hastype T \vdash i \hastype P[x,x,\ha\refl{}] \\
    \Gamma \vdash t_1 \hastype T \\ 
    \Gamma \vdash t_2 \hastype T \\
    \Gamma \vdash e \hastype t_1 \identity t_2 \hastype T
  }
            {
              \Gamma \vdash \ha\JJ{T,...P,.i,t_1,t_2,e} \hastype P[t_1,t_2,e]
            }\and
  \inferrule{
    \Gamma \vdash T \FTYPE \\ 
    \Gamma, x_1 \hastype T, x_2 \hastype T, e \hastype x_1 \identity x_2 \hastype T \vdash P \FTYPE \\
    \Gamma, x \hastype T \vdash i \hastype P[x,x,\ha\refl{}] \\
    \Gamma \vdash t \hastype T
  }
            {
              \Gamma \vdash \ha\wJ{} \hastype \ha\JJ{T,...P,.i,t,t,\ha\refl{}} \equality i[t] \hastype P[t,t,\ha\refl{}]
            }\and
  \inferrule{
    \Gamma \vdash T \FTYPE \\
    \Gamma \vdash T' \FTYPE \\
    \Gamma \vdash p_1 \hastype t_1 \equality t'_1 \hastype T \equality T' \\
    \Gamma \vdash p_2 \hastype t_2 \equality t'_2 \hastype T \equality T'}
            {\Gamma \vdash \ha\Wid{p_1,p_2} \hastype (t_1 \identity t_2 \hastype T) \equality (t'_1 \identity t'_2 \hastype T')} \and
  \inferrule{
    \Gamma \vdash T \FTYPE \\
    \Gamma \vdash T' \FTYPE \\
    \Gamma \vdash p \hastype t \equality t' \hastype T \equality T'}
            {\Gamma \vdash \ha\wrefl{} \hastype \ha\refl{} \equality \ha\refl{} \hastype \ha\Wid{p,p} : (t \identity t \hastype T) \equality (t' \identity t' \hastype T')} \and

\end{mathparpagebreakable}


\end{enumerate}

\bibliography{alggeom}
\bibliographystyle{plain}
\end{document}
  %% Local Variables:
  %% compile-command: "pdflatex TTS-internal-witnesses.tex "
  %% End:
